<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算工作流——初识Atomate2</title>
    <url>/2024/11/08/Atomate2-1/</url>
    <content><![CDATA[<p><code>Atomate2</code> ​是一款开源可用来处理复杂庞大计算任务的软件包，开发团队也是大名鼎鼎的劳伦斯伯克利国家实验室的研究人员，耳熟能详的 <code>pymatgen</code>​、<code>Materials Project</code>​、<code>FireWorks</code> ​等也是出自该团队之手。</p>
<p><code>Atomate2</code> ​环境配置可参考<a href="https://materialsproject.github.io/atomate2/user/install.html">官网</a>进行。</p>
<p>在此之前，强烈建议先了解学习一下 <code>pymatgen</code> ​的用法！老司机之前也出过相关介绍。如果在此之前有了解过或使用过 <code>pymatgen</code> ​的朋友，那么 <code>Atomate2</code> ​使用起来应该会更加容易上手，而且用习惯之后，发现 <code>Atomate2</code> ​用起来更加顺手。下面先贴一个官网上的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.jobs.core <span class="keyword">import</span> RelaxMaker</span><br><span class="line"><span class="keyword">from</span> jobflow.managers.local <span class="keyword">import</span> run_locally</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">relax_job = RelaxMaker().make(si_structure)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_locally(relax_job, create_folders=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，意思是优化 <code>Si</code> ​单质结构，整段代码又三部分组成：</p>
<ul>
<li>定义结构</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>指定任务&#x2F;工作流</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relax_job = RelaxMaker().make(si_structure)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run_locally(relax_job, create_folders=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>有人会问，如果只用 <code>pymatgen</code> ​能不能实现同样的功能，答案是肯定的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义结构</span></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成输入文件</span></span><br><span class="line">relax_set = MPRelaxSet(si_structure)</span><br><span class="line">relax_set.write_input(<span class="string">&#x27;./&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>相比于 <code>Atomate2</code> ​的代码，如果仅仅从单个的计算任务来说，<code>pymatgen</code> ​差别不大，都是读结构，进行单次计算。</p>
<p>但是对于多步计算，如多步优化，能带态密度等计算，<code>pymatgen</code> ​该如何实现，一般来说，我们需要把每一步的计算输入相关的代码都写好，比如计算 <code>Si</code> ​的能带：</p>
<ul>
<li>结构优化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relax_set = MPRelaxSet(si_structure)</span><br><span class="line">relax_set.write_input(<span class="string">&#x27;relax&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行 <code>vasp</code> ​计算</p>
<ul>
<li>静态计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取优化的结果</span></span><br><span class="line">static_set = MPStaticSet.from_prev_calc(prev_dir=<span class="string">&#x27;relax&#x27;</span>)</span><br><span class="line">static_set.write_input(<span class="string">&#x27;static&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行 <code>vasp</code> ​计算</p>
<ul>
<li>能带计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取静态计算的结果</span></span><br><span class="line">nonscf_set = MPNonScfSet.from_prev_calc(prev_dir=<span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">nonscf_set.write_input(<span class="string">&#x27;band&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行 <code>vasp</code> ​计算</p>
<p>只使用 <code>pymatgen</code>​，从提交任务的次数来说，需要提交三次 <code>vasp</code> ​任务，而且整个计算过程是中断的，每一次计算都需要人力去手动提交，比较麻烦。而且如果你使用的是公用集群，且恰好集群用的人比较多，计算资源比较紧张，那么你很难保证上一步计算完成后，手动提交的下一步任务能马上开始计算，可能要排很久的队，这样一来，计算周期就不可控的变长了。</p>
<p>如果要使用 <code>Atomate2</code> ​来完成上述计算任务的话，代码会非常简单明了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.core <span class="keyword">import</span> RelaxBandStructureMaker</span><br><span class="line"><span class="keyword">from</span> jobflow.managers.local <span class="keyword">import</span> run_locally</span><br><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">bandstructure_flow = RelaxBandStructureMaker().make(si_structure)</span><br><span class="line"></span><br><span class="line">run_locally(bandstructure_flow, create_folders=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码省略了可自定义的 <code>INCAR</code>​、<code>KPOINTS</code> ​等参数设置。</p>
<p>有 <code>pymatgen</code> ​代码对比，相当于 <code>bandstructure_flow = RelaxBandStructureMaker().make(si_structure)</code> ​这一行代码包含了 <code>pymatgen</code> ​三个分步计算过程，从代码的结构上看更加的简洁易懂，而且最关键的是自动控制任务的进行，只需要提交一次任务即可。相当于把单个独立的子任务串联了起来，这便是“工作流”了。</p>
<p>后面会逐步来介绍如何使用 <code>Atomate2</code> ​来调用&#x2F;自定义工作流来高效进行计算。</p>
<p>‍</p>
]]></content>
      <categories>
        <category>Atomate2</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>Atomate2</tag>
      </tags>
  </entry>
  <entry>
    <title>计算工作流——Atomate2基本设置</title>
    <url>/2024/11/09/Atomate2-2/</url>
    <content><![CDATA[<p><code>Atomate2</code>​安装过程<a href="https://materialsproject.github.io/atomate2/user/install.html">官网</a>上介绍的已经非常详细了，唯一需要注意的是云数据库的设置。<code>Atomate2</code>​推荐采用云数据库来存储工作量计算结果，官网给出的例子为使用<code>Mongdb Atlas</code>​。但是由于一些原因，采用云数据库来储存数据，对于个人用户来说不是很友好，特别是国内用户：</p>
<ul>
<li>由于“局域网”问题，许多集群可能连接不上<code>Mongdb Atlas</code>​，或者速度比较慢，容易掉线；</li>
<li>云数据库要花钱购买存储空间，<code>Mongdb Atlas</code>​也只提供500M的免费空间，长期来看也是不够用的，不管你是学生还是社畜，咱自己总不能倒贴上班吧；</li>
<li>小批量计算没有这个必要，个人用户自己计算的东西，体量实在太小，没必要纠结于按照官网教程来配置数据库，我们主要是使用<code>Atomate2</code>​方便的工作流。</li>
</ul>
<p><strong>Note：</strong> 当然，如果你单位有这个条件搭建数据库，那自然是更好的QAQ。</p>
<p>采用本地读取数据，实际上官网上也给出了相应的介绍，只需要把对应的<code>jobflow.yaml</code>​文件设置成以下格式：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101112554-88e2sbd.png" alt="image"></p>
<p>‍</p>
<p>自此，假设你已经完成了<code>pymatgen</code>​的配置（<code>pymatgen</code>​的配置之前出过详细的教程，可查看往期内容），<code>Atomate2</code>​的配置，那么接下来就可以正式进入<code>Atomate2</code>​的实操了。</p>
<h2 id="Atomate2可运行任务-工作流类型"><a href="#Atomate2可运行任务-工作流类型" class="headerlink" title="Atomate2可运行任务&amp;工作流类型"></a>Atomate2可运行任务&amp;工作流类型</h2><p>下表为<code>Atomate2</code>​已经为你预制的计算类型，实际使用时只需要进行调用即可：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241014143658-dfvi8jf.png" alt="image"></p>
<p>根据任务<code>Type</code>​不同，<code>job</code>​任务的调用为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.jobs.core <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p><code>flow</code>​任务的调用为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.core <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>除此上述“基本”的工作流之外，<code>Atomate2</code>​还有相对复杂的工作流，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.adsorption <span class="keyword">import</span> AdsorptionMaker</span><br></pre></td></tr></table></figure>

<p>这是一个计算吸附能的工作流，具体流程为：</p>
<blockquote>
<p>The flow consists of the following steps:</p>
<ol>
<li>Optimize the molecule structure and calculate its static energy.</li>
<li>Optimize the bulk structure.</li>
<li>Generate a slab structure using the optimized bulk structure and calculate its static energy.</li>
<li>Generate adsorption sites on the slab and calculate corresponding static energy.</li>
<li>Calculate the adsorption energy by calculating the energy difference between the slab with adsorbed molecule and the sum of the slab without the adsorbed molecule and the molecule.</li>
</ol>
</blockquote>
<p>吸附能工作流相对来说比较复杂，涉及到多步计算以及结构变化操作，工作流中的每一个<code>task</code>​的参数设置都要格外小心，相对于上述“基本”工作流而言，属于“进阶”工作流，如果用好了的话会非常方便，当然也有它的使用局限性，我们后面再介绍。</p>
<h2 id="工作流的组成"><a href="#工作流的组成" class="headerlink" title="工作流的组成"></a>工作流的组成</h2><p>本小节是本篇内容的核心部分。</p>
<p><code>Atomate2</code>​给出的工作流中，关键参数是已经提供了默认值的，例如之前给出得例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.core <span class="keyword">import</span> RelaxBandStructureMaker</span><br><span class="line"><span class="keyword">from</span> jobflow.managers.local <span class="keyword">import</span> run_locally</span><br><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">bandstructure_flow = RelaxBandStructureMaker().make(si_structure)</span><br><span class="line"></span><br><span class="line">run_locally(bandstructure_flow, create_folders=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>算<code>Si</code>​的能带态密度结构，直接按照上面的代码提交任务进行<code>vasp</code>​计算，计算完成后可以在当前路径下找到五个文件夹：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101143803-0om1g53.png" alt="image"></p>
<p>我们找到<code>RelaxBandStructureMaker</code>​的文档注释看一下：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101143917-2ifabtu.png" alt="image"></p>
<p>实际上，<code>RelaxBandStructureMaker</code>​是调用了<code>relax_maker</code>​和<code>band_structure_maker</code>​，然后查看源代码可以发现：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101144202-vcm5q25.png" alt="image"></p>
<p>工作流结构优化部分是调用了<code>DoubleRelaxMaker</code>​，能带结构分析调用了<code>BandStructureMaker</code>​，继续顺藤摸瓜：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101144508-743errg.png" alt="image"></p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101144442-0owjoby.png" alt="image"></p>
<p>可以发现，<code>DoubleRelaxMaker</code>​进行了两个结构优化任务，<code>BandStructureMaker</code>​进行了一个静态自洽计算，两个非自洽计算，这也是为什么计算完成后会有5个计算文件夹。</p>
<p>计算文件夹命名可以根据时间来区分，即自上而下分别是：第一次结构优化、第二次结构优化、静态自洽、uniform 非自洽计算、line 非自洽计算。</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101143803-0om1g53.png" alt="image">​</p>
<p><strong>Note：</strong> 上述uniform 非自洽计算即态密度计算，line 非自洽计算才是能带计算结果。可以在<code>bandstructure_type</code>​中选择计算哪种或者都计算。</p>
<p>回到计算结果，<code>Atomate2</code>​计算完成后，对于顺利结束的任务，会自动打包为<code>.gz</code>​格式的文件；反之，如果任务有<code>ERROR</code>​或<code>WARNING</code>​之类，则不会打包文件。</p>
<p>上述计算中，结果优化与静态自洽计算都正常结束，后两步非自洽计算都出现了报错，报错内容可以在每个文件夹中<code>custodian.json</code>​文件中查看：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101152919-bey421h.png" alt="image"></p>
<p>实际上这个<code>error</code>​就是<code>INCAR</code>​中<code>NBANDS</code>​设置有误，但是在实际计算中由于<code>VASP</code>​可以自行调整部分参数：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101153256-yqf2d62.png" alt="image"></p>
<p>实际上计算也是可以正常结束的。</p>
<p>但是这不意味着在实际使用过程中可以信赖默认的参数，最稳妥以及保险的做法，还是要自定义输入参数！</p>
<h2 id="自定义输入参数"><a href="#自定义输入参数" class="headerlink" title="自定义输入参数"></a>自定义输入参数</h2><p>通过查看<code>Atomate2</code>​的文档说明，实际上<code>Atomate2</code>​的输入参数也是直接调用的<code>pymatgen</code>​的各类<code>sets</code>​的默认输入，可以去<code>pymatgen</code>​源代码中查看yaml格式文件<a href="https://github.com/materialsproject/pymatgen/tree/master/src/pymatgen/io/vasp">Link</a>。</p>
<p>还有一点需要注意，随着<code>VASP</code>​的更新，<code>pymatgen</code>​的<code>sets</code>​的默认参数也会更新。在<code>Atomate2</code>​里面，<code>relax</code>​操作调用的是<code>pymatgen</code>​中的<code>MPSCANRelaxSet</code>​的默认输入，其中部分<code>INCAR</code>​词条的设置只适用于<code>VASP 6+</code>​版本，如果你使用的还是<code>VASP 5.4.4</code>​版本的话，推荐在<code>Atomate2</code>​使用中还是使用<code>MPRelaxSet</code>​，下面会详细说明。</p>
<p>回到上述<code>Si</code>​单质计算能带态密度工作流的案例，下面将详细的说明在每一步里面如何合理的自定义输入参数：</p>
<ul>
<li>relax步骤</li>
</ul>
<p>以<code>RelaxMaker</code>​为例，主要是需要区分<code>input_set_generator</code>​和<code>write_input_set_kwargs</code>​的区别，其余的设置都可以采用默认。</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101155155-6q16vdd.png" alt="image"></p>
<p>通俗的来讲，<code>input_set_generator</code>​控制输入文件的设置，可以约等于<code>set</code>​类，如<code>MPRelaxSet</code>​；而<code>write_input_set_kwargs</code>​可传入的参数更多，可以传<code>input_set_generator</code>​、<code>structure</code>​、<code>output_path</code>​等等，自由度更高。但是目前来说，只修改<code>input_set_generator</code>​就可以满足绝大多数使用场景了。</p>
<p>由于本人使用的是<code>VASP 5.4.4</code>​，这里重新调用了<code>pymatgen</code>​的<code>MPRelaxSet</code>​来生成输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># relax</span></span><br><span class="line">relax_input_set = MPRelaxSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">relax_maker = RelaxMaker(input_set_generator=relax_input_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># static</span></span><br><span class="line">static_input_set = MPStaticSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>,  <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">True</span>&#125;)</span><br><span class="line">static_maker = StaticMaker(input_set_generator=static_input_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nonscf</span></span><br><span class="line">nsf_input_set = MPNonSCFSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;NBANDS&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">nsf_maker = NonSCFMaker(input_set_generator=nsf_input_set)</span><br></pre></td></tr></table></figure>

<p><strong>Note：</strong>​<code>relax</code>​步骤只采取了一步优化，所以对应的最后输出的计算文件夹个数只有四个。</p>
<p>上面针对所有的计算<code>task</code>​的输入进行了自定义，然后就是进行组合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bandstrucure_maker</span></span><br><span class="line">band_maker = BandStructureMaker(static_maker=static_maker,bs_maker=nsf_maker)</span><br><span class="line"></span><br><span class="line"><span class="comment"># relaxbandstructure_flow</span></span><br><span class="line">relaxbandstructure_flow = RelaxBandStructureMaker(relax_maker=relax_maker,band_structure_maker=band_maker).make(si_structure)</span><br></pre></td></tr></table></figure>

<p>至此，整个工作流的输入实现了自定义。关于<code>sets</code>​类的参数设置可以参考本人之前写的<code>pymatgen</code>​教程。</p>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.jobs.core <span class="keyword">import</span> RelaxMaker, StaticMaker, NonSCFMaker</span><br><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.core <span class="keyword">import</span> RelaxBandStructureMaker, BandStructureMaker</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet, MPStaticSet, MPNonSCFSet</span><br><span class="line"><span class="keyword">from</span> jobflow <span class="keyword">import</span> run_locally, JobStore, SETTINGS</span><br><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">work_dir = os.getcwd()</span><br><span class="line"></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义输入设置</span></span><br><span class="line">relax_input_set = MPRelaxSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">static_input_set = MPStaticSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>,  <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">True</span>&#125;)</span><br><span class="line">nsf_input_set = MPNonSCFSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;NBANDS&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入maker</span></span><br><span class="line">relax_maker = RelaxMaker(input_set_generator=relax_input_set)</span><br><span class="line">static_maker = StaticMaker(input_set_generator=static_input_set)</span><br><span class="line">nsf_maker = NonSCFMaker(input_set_generator=nsf_input_set)</span><br><span class="line">band_maker = BandStructureMaker(static_maker=static_maker,bs_maker=nsf_maker)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工作流</span></span><br><span class="line">relaxbandstructure_flow = RelaxBandStructureMaker(relax_maker=relax_maker,band_structure_maker=band_maker).make(si_structure)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行工作流</span></span><br><span class="line">run_locally(relaxbandstructure_flow, create_folders=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>运行方法：如果是个人电脑上运行，可以直接<code>python relaxband.py</code>​运行上述脚本；如果是在集群上，需要修改下提交脚本，下面以<code>slurm</code>​作业调度系统为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J relaxband</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -p long</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --time=2400:00:00</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --nodes=1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --output=%j.log</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载VASP</span></span><br><span class="line">module load /path/vasp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入atomate2环境</span></span><br><span class="line">source activate atomate2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行脚本</span></span><br><span class="line">python relaxband.py &amp;&gt;output</span><br></pre></td></tr></table></figure>

<p>计算完成后，当前路径下会生成四个文件夹，分别是：结构优化、静态计算、态密度计算、能带计算：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101170219-u2afkrh.png" alt="image"></p>
<p>工作流的参数自定义大致操作就是这样。学会举一反三，对于其他类型工作流的参数自定义设置也类似，想要进一步的去理解和个性化设置，鼓励各位还是要去看看文档和源代码。</p>
<h2 id="工作流JSON文件"><a href="#工作流JSON文件" class="headerlink" title="工作流JSON文件"></a>工作流JSON文件</h2><p><code>Atomate2</code>​在工作流计算完成后，会生成<code>doc</code>​文档来记录部分计算结果，具体设置由<code>jobflow.yaml</code>​文件控制。需要说明的是，如果采用云数据库的话，除了<code>doc</code>​文档的话还会有<code>data</code>​文件来储存数据，如上述<code>relaxbandstructure</code>​工作流最后得到态密度和能带可以直接从<code>data</code>​里面读取，而不需要从<code>VASP</code>​的输出文件：<code>OUTCAR</code>​或<code>vasprun.xml</code>​文件中进行后处理。</p>
<p>但是，如果采用的是本地储存的话，实际上<code>data</code>​文件是为空的，本人也暂时不知道为啥，官方论坛上也暂时检索不到解决办法，具体报错内容为：<code>WARNING Response.stored_data is not supported with local manager</code>​。如果有大佬知道如何解决，可以分享一下。</p>
<p>但是无论如何，即使没有<code>data</code>​文件，大不了通过处理<code>OUTCAR</code>​或<code>vasprun.xml</code>​来得到相关数据，从结果上来没有什么区别。</p>
<p>这里简单介绍一下<code>doc</code>​文档，<code>doc</code>​文档的路径即<code>jobflow.yaml</code>​中给定的路径，文件格式为<code>JSON</code>​格式，官网上对文档的结构有详尽的介绍：<a href="https://materialsproject.github.io/atomate2/user/docs_schemas_emmet.html">Link</a>。这里不赘述。</p>
<p>主要是针对计算时的操作给出一点建议。如果我们有多个结构需要进行<code>relaxbandstructure</code>​工作流计算，按照上述代码结构批量提交了之后，我们最终得到的<code>doc</code>​文档是所有结构工作流的信息，也就是<code>doc</code>​文档不会去根据任务数量在<code>jobflow.yaml</code>​中定义的路径下针对不同的任务新建不同的<code>doc</code>​，而是在原有的<code>doc</code>​文档末尾添加新的信息，久而久之，<code>doc</code>​文档会非常冗长，可读性差。所以，建议把<code>doc</code>​文档保存在每个工作流目录下，只需要在上述代码中做如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> atomate2.vasp.jobs.core <span class="keyword">import</span> RelaxMaker, StaticMaker, NonSCFMaker</span><br><span class="line"><span class="keyword">from</span> atomate2.vasp.flows.core <span class="keyword">import</span> RelaxBandStructureMaker, BandStructureMaker</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet, MPStaticSet, MPNonSCFSet</span><br><span class="line"><span class="keyword">from</span> jobflow <span class="keyword">import</span> run_locally, JobStore, SETTINGS</span><br><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">work_dir = os.getcwd()</span><br><span class="line"></span><br><span class="line">si_structure = Structure(</span><br><span class="line">    lattice=[[<span class="number">0</span>, <span class="number">2.73</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">0</span>, <span class="number">2.73</span>], [<span class="number">2.73</span>, <span class="number">2.73</span>, <span class="number">0</span>]],</span><br><span class="line">    species=[<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>],</span><br><span class="line">    coords=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义输入设置</span></span><br><span class="line">relax_input_set = MPRelaxSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">static_input_set = MPStaticSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>,  <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">True</span>&#125;)</span><br><span class="line">nsf_input_set = MPNonSCFSet(user_incar_settings=&#123;<span class="string">&quot;ENCUT&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;NBANDS&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>, <span class="string">&quot;LCHARG&quot;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入maker</span></span><br><span class="line">relax_maker = RelaxMaker(input_set_generator=relax_input_set)</span><br><span class="line">static_maker = StaticMaker(input_set_generator=static_input_set)</span><br><span class="line">nsf_maker = NonSCFMaker(input_set_generator=nsf_input_set)</span><br><span class="line">band_maker = BandStructureMaker(static_maker=static_maker,bs_maker=nsf_maker)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工作流</span></span><br><span class="line">relaxbandstructure_flow = RelaxBandStructureMaker(relax_maker=relax_maker,band_structure_maker=band_maker).make(si_structure)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作流文件夹</span></span><br><span class="line">relaxband_dir = os.path.join(work_dir, <span class="string">&quot;relaxband&quot;</span>)</span><br><span class="line">os.makedirs(relaxband_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建docs和data文件夹存储doc文档和data数据</span></span><br><span class="line">docs_path = os.path.join(relaxband_dir, <span class="string">&quot;docs&quot;</span>)</span><br><span class="line">data_path = os.path.join(relaxband_dir, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">os.makedirs(docs_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">os.makedirs(data_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换jobflow.yaml文件中的路径</span></span><br><span class="line">SETTINGS.JOB_STORE.docs_store.paths = [os.path.join(docs_path,<span class="string">&#x27;doc.json&#x27;</span>)]</span><br><span class="line">SETTINGS.JOB_STORE.additional_stores[<span class="string">&#x27;data&#x27;</span>].paths = [os.path.join(data_path,<span class="string">&#x27;data.json&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行工作流</span></span><br><span class="line">run_locally(relaxbandstructure_flow, create_folders=<span class="literal">True</span>, root_dir=relaxband_dir)</span><br></pre></td></tr></table></figure>

<p>最终可以在工作流文件夹下生成对应的<code>doc</code>​文档和<code>data</code>​数据文件夹，实现每个工作流的信息独立存储：</p>
<p><img src="/2024/11/09/Atomate2-2/image-20241101173348-cjgt78o.png" alt="image"></p>
<p>‍</p>
<p><strong>To be continued……</strong></p>
<p>‍</p>
]]></content>
      <categories>
        <category>Atomate2</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>Atomate2</tag>
      </tags>
  </entry>
  <entry>
    <title>计算工作流——Atomate2自定义工作流</title>
    <url>/2024/11/10/Atomate2-3/</url>
    <content><![CDATA[<p><code>Atomate2</code>​除了直接调用现成的工作流，我们还可以根据个人需求自定义任务个数以及工作流走向。具体操作也非常简单，只需要在<code>Flow</code>​中按照计算顺序传入任务即可，如果我们需要优化一个结构并进行静态计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jobflow <span class="keyword">import</span> Flow</span><br><span class="line"><span class="keyword">from</span> atomate2.vasp.jobs.core <span class="keyword">import</span> RelaxMaker, StaticMaker</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">si_structure = Structure.from_file(<span class="string">&quot;Si.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a relax job</span></span><br><span class="line">relax_job = RelaxMaker().make(structure=si_structure)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a static job that will use only the structure from the relaxation</span></span><br><span class="line">static_job = StaticMaker().make(structure=relax_job.output.structure)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a static job that will use additional outputs from the relaxation</span></span><br><span class="line">static_job = StaticMaker().make(</span><br><span class="line">    structure=relax_job.output.structure, prev_dir=relax_job.output.dir_name</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a flow including the two jobs and set the output to be that of the static</span></span><br><span class="line">my_flow = Flow([relax_job, static_job], output=static_job.output)</span><br></pre></td></tr></table></figure>

<p>上面是官网的例子，通过<code>Flow</code>​方法把两个任务按照顺序组合起来，既可以实现结构优化完自动开始静态计算。</p>
<p>此外，根据实际计算中，我们是否需要续算，或者读取上一步的计算结果，可以在<code>make()</code>​方法中定义：</p>
<ul>
<li><code>structure</code>​：读取上一步计算的优化结构的语法为<code>prev_job.output.structure</code>​</li>
<li><code>prev_dir</code>​：读取上一步计算的文件夹，主要是可用于继承<code>INCAR</code>​设置，或复制读取<code>CHGCAR</code>​和<code>WAVECAR</code>​文件。</li>
</ul>
<p>适用的用法即静态计算中读取弛豫计算的结构，非自洽计算中读取静态计算的<code>CHGCAR</code>​等。</p>
<p>因此，上述的<code>my_flow</code>​根据需求可以继续增加任务，如继续计算态密度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">dos_job = NonSCFMaker().make(structure=static_job.output.structure, prev_dir=static_job.output.dir_name)</span><br><span class="line"></span><br><span class="line">my_flow = Flow([relax_job, static_job, dos_job], output=dos_job.output)</span><br></pre></td></tr></table></figure>

<p>至此，<code>Atomate2</code>​的基本用法就大致介绍完了~~~~~~~~</p>
]]></content>
      <categories>
        <category>Atomate2</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>Atomate2</tag>
      </tags>
  </entry>
  <entry>
    <title>FireWorks——材料计算工作流的归属？</title>
    <url>/2025/02/28/FireWorks-intro/</url>
    <content><![CDATA[<p>当我们回溯材料计算研究者的成长轨迹，会发现工作流管理工具的演进恰似一场层层突破的修行：</p>
<p>【启蒙阶段：刀耕火种】<br> 初入课题组时，导师递来的”葵花宝典”成为叩开计算材料学大门的密钥。VASP​ 手册里晦涩的INCAR参数，像一串等待破译的密码；在Linux终端反复调试的bash脚本，记录着与POSCAR较劲的日日夜夜。这个阶段的研究者如同匠人，用记事本雕琢每个计算任务，用肉眼比对OUTCAR中的能量收敛曲线。</p>
<p>【进阶工具：批量觉醒】<br> 当pymatgen​ 的Structure对象开始替代手工建模，当ASE的Atoms模块实现晶格参数的自动化调整，研究者终于挣脱了重复劳动的枷锁。笔者仍记得第一次用pymatgen​ 批量处理200个分子吸附构型时的震撼——原本需要数周的建模工作，在Python脚本的魔法下仅需一杯咖啡的时间。</p>
<p>【自动化跃迁：流程封装】<br> ​Atomate2​ 的出现如同打开潘多拉魔盒，将DFT计算分解成可复用的”乐高模块”：结构优化→静态计算→能带分析。Jobflow​ 的DAG（有向无环图）引擎更让任务编排突破线性束缚，当我们在超算平台同时提交50个掺杂体系的电子结构计算时，忽然意识到计算流程已从”流水线作业”进化到”智能工厂”模式。</p>
<p>【终极归属：工作流交响】<br> 而FireWorks​ 的登场，才真正奏响了高通量计算的交响乐章。通过三大创新重构了计算范式：</p>
<ol>
<li>状态机架构：每个计算任务被抽象为Firework对象，其状态变迁（待运行→执行中→完成&#x2F;失败）由LaunchPad统一调度</li>
<li>容错重生：当某个节点因超算队列波动失败时，智能重试机制能自动续接断点，配合MongoDB的持久化存储确保流程韧性</li>
<li>多尺度融合：通过自定义的FWAction机制，轻松实现第一性原理计算→机器学习势训练→分子动力学模拟的跨尺度串联</li>
</ol>
<p>在FireWorks 的世界里，材料基因组计划的宏愿变得触手可及。当我们用YAML文件定义好相图搜索工作流，看着成千上万个虚拟晶体结构在云端自动生成、计算、分析，最终汇聚成热力学稳定性图谱时，终于领悟到：这不只是工具的进化，更是研究范式的革命——从此，计算材料学家得以将心智从机械操作中解放，真正回归材料设计的本质思考。</p>
<p>FireWorks 是一个免费且开源的工作流管理软件，旨在定义、管理和执行复杂的工作流。用使用 Python、JSON 或 YAML 来定义工作流，这些工作流存储在 MongoDB 数据库中，并可通过内置的 Web 界面进行监控。</p>
<p><img src="/2025/02/28/FireWorks-intro/image-20250210155500-nrrl9gx.png" alt="image-20250210155500-nrrl9gx"></p>
<p>主要功能：</p>
<ol>
<li><p>灵活的接口：FireWorks 提供了简洁灵活的 Python API、强大行界面，以及用于监控工作流的内Web 服务。这种多样化的接口使用户能够根据自身需求选择最适合的方FireWorks 交互。</p>
</li>
<li><p>数端： 通过 MongoDB 数据库，用户可以添加、删除和搜索工作流的状态。这种数据库支持使得工作流管理更加高效和有序。</p>
</li>
<li><p>故障检测与重试：FireWorks 能够检测到流中的软故障和硬故障，并根据需要重新运行失败的任务，确保工作流的可靠性和稳定性。</p>
</li>
<li><p>多种执行模式：支持在多核机器上直接执行或通过队列系统执行，既可以机器上运行，也可以在多台机器上。用户可以为任务分配优先级，并指定任务的运行位置，以满足不同的计算需求。</p>
</li>
<li><p>动态工作流： FireWorks 支持根过程中的情况，自动修改自身或创建新的流。这种动态调整能力使得工作流能够适应变化的需求和条件。</p>
</li>
<li><p>自动处理重复任务：工作流级别，FireWorks 能够自动跳过重复的部分，仅运行独特的部分，提高了执行效率。</p>
</li>
<li><p>内置任务： 提于创建模板化输入、运行脚本以及将文件到远程机器的内置任务，简化了常见操作的执行。</p>
</li>
<li><p>远程文件状态跟踪： 在执行过程中户可以远程跟踪输出文件的状态，方便监控和调试。</p>
</li>
<li><p>任务打包： 能够将许多小任务打包成一个大任务，自动在 100 个核心上并行运行 100 个串行工作流，提高资源利用率。</p>
</li>
<li><p>队列系统支持： 支持多种队列系统，如 PBS&#x2F;Torque、Sun Grid EnginLURM 和 IBM LoLeveler，适应不同的计算环境。</p>
</li>
</ol>
<p>工作流模型： 在 FireWorks 中，工作以下三个主要组件组成：</p>
<ul>
<li>Firetask： 这是一个原子计算任务，可以调用shell 脚本或执行用户定义的 thon 函数。</li>
<li>Firework： 包含执行任务所需的 JSON 规范，包括要按顺序执行的 Fireta数组，以及传递给 Firetask输入参数。</li>
<li>Workflow： 由多个 Firework 组成，并定义它们之间的依赖关系，例如，某个父级 Firework 完成并生文，才能运行其子级 Firework。</li>
</ul>
<p>通过这些组件，用户可以构杂且动态的工作流，以满足各种计算需求。</p>
]]></content>
      <categories>
        <category>WorkFlow</category>
      </categories>
      <tags>
        <tag>FireWorks</tag>
        <tag>WorkFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.1  计算小白硬学VASP —— 前言</title>
    <url>/2024/05/29/Learn-VASP-from-pymatgen-1/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>我是炫酷老司机，欢迎来到《计算小白硬学VASP》系列。</p>
<p>本系列不涉及DFT理论！不涉及DFT理论！不涉及DFT理论！主要目的是通过实例学习如何让VASP跑起来，不需要记INCAR, POTCAR, KPOINTS, POSCAR, CONTCAR等各种文件。</p>
<p>配合上好大哥——pymatgen，实现各种计算类型输入文件生成脚本化，计算流程以及计算结果处理自动化，尽可能解放双手，告别vim。</p>
<p>本人非大佬，普通DFT民工一名，不涉及教学，只分享经验，欢迎指正，不喜勿喷，共同进步。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.10  计算小白硬学VASP —— 材料性质计算—&gt;能带态密度图汇总</title>
    <url>/2024/06/28/Learn-VASP-from-pymatgen-10/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何把能带态密度画在一起，也就是常见的能带图在左，态密度图垂直在右分布。这里需要调用的模块为<code>BSDOSPlotter()</code>。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSDOSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取dos计算vasprun.xml文件</span></span><br><span class="line">dos_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/dos/vasprun.xml&quot;</span>)</span><br><span class="line">dos = dos_vasprun.complete_dos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取band计算vasprun.xml文件</span></span><br><span class="line">band_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>)</span><br><span class="line">band = band_vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化BSDOSPlotter类</span></span><br><span class="line">plotter = BSDOSPlotter()</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plotter.get_plot(bs=band,dos=dos)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/28/Learn-VASP-from-pymatgen-10/image-20240628171711926.png" alt="image-20240628171711926"></p>
<h4 id="绘制元素-轨道投影"><a href="#绘制元素-轨道投影" class="headerlink" title="绘制元素&#x2F;轨道投影"></a>绘制元素&#x2F;轨道投影</h4><p>绘制能带元素投影时，需要在读取<code>vasprun.xml</code>文件时增加提取投影信息的参数：<code>Vasprun(&quot;vasprun.xml&quot;,parse_projected_eigen=True)</code></p>
<p>修改代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSDOSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取dos计算vasprun.xml文件</span></span><br><span class="line">dos_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/dos/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">dos = dos_vasprun.complete_dos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取band计算vasprun.xml文件</span></span><br><span class="line">band_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">band = band_vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化BSDOSPlotter类</span></span><br><span class="line">plotter = BSDOSPlotter()</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plotter.get_plot(bs=band,dos=dos)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/28/Learn-VASP-from-pymatgen-10/image-20240628172049701.png" alt="image-20240628172049701"></p>
<p>此时可以看到左边的能带图也对应显示了元素的投影。</p>
<p>该方法默认为<code>band</code>和<code>dos</code>采用元素投影，初次之外<code>dos</code>还提供了轨道投影选项，需要在实例化<code>BSDOSPlotter()</code>时增加<code>dos_projection=&#39;orbitals&#39;</code>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSDOSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取dos计算vasprun.xml文件</span></span><br><span class="line">dos_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/dos/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">dos = dos_vasprun.complete_dos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取band计算vasprun.xml文件</span></span><br><span class="line">band_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">band = band_vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化BSDOSPlotter类，态密度为轨道投影</span></span><br><span class="line">plotter = BSDOSPlotter(dos_projection=<span class="string">&#x27;orbitals&#x27;</span>)</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plotter.get_plot(bs=band,dos=dos)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/28/Learn-VASP-from-pymatgen-10/image-20240628172755948.png" alt="image-20240628172755948"></p>
<p>如果只想表现TDOS，则在实例化<code>BSDOSPlotter()</code>时设置<code>dos_projection=&#39;None&#39;</code>和<code>bs_projection=None</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSDOSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取dos计算vasprun.xml文件</span></span><br><span class="line">dos_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/dos/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">dos = dos_vasprun.complete_dos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取band计算vasprun.xml文件</span></span><br><span class="line">band_vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>,parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line">band = band_vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化BSDOSPlotter类</span></span><br><span class="line">plotter = BSDOSPlotter(bs_projection=<span class="literal">None</span>,dos_projection=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plotter.get_plot(bs=band,dos=dos)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/28/Learn-VASP-from-pymatgen-10/image-20240628173052926.png" alt="image-20240628173052926"></p>
<p>最后，需要调整y轴范围、线条颜色，字体大小，图例大小等，都可以在实例化<code>BSDOSPlotter()</code>时设置相应的参数：</p>
<blockquote>
<ul>
<li><strong>bs_projection</strong> (<em>‘elements’</em> <em>|</em> <em>None</em>) – Whether to project the bands onto elements.</li>
<li><strong>dos_projection</strong> (<em>str</em>) – “elements”, “orbitals”, or None</li>
<li><strong>vb_energy_range</strong> (<em>float</em>) – energy in eV to show of valence bands</li>
<li><strong>cb_energy_range</strong> (<em>float</em>) – energy in eV to show of conduction bands</li>
<li><strong>fixed_cb_energy</strong> (<em>bool</em>) – If true, the cb_energy_range will be interpreted as constant (i.e., no gap correction for cb energy)</li>
<li><strong>egrid_interval</strong> (<em>float</em>) – interval for grid marks</li>
<li><strong>font</strong> (<em>str</em>) – font family</li>
<li><strong>axis_fontsize</strong> (<em>float</em>) – font size for axis</li>
<li><strong>tick_fontsize</strong> (<em>float</em>) – font size for axis tick labels</li>
<li><strong>legend_fontsize</strong> (<em>float</em>) – font size for legends</li>
<li><strong>bs_legend</strong> (<em>str</em>) – matplotlib string location for legend or None</li>
<li><strong>dos_legend</strong> (<em>str</em>) – matplotlib string location for legend or None</li>
<li><strong>rgb_legend</strong> (<em>bool</em>) – (T&#x2F;F) whether to draw RGB triangle&#x2F;bar for element proj.</li>
<li><strong>fig_size</strong> (<em>tuple</em>) – dimensions of figure size (width, height)</li>
</ul>
</blockquote>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.13  计算小白硬学VASP —— 自动搜索表面吸附位点并生成吸附结构</title>
    <url>/2024/08/07/Learn-VASP-from-pymatgen-13/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何在<code>slab</code>模型表面自动搜索吸附位点并生成吸附模型。</p>
<h3 id="AdsorbateSiteFinder搜索吸附位点"><a href="#AdsorbateSiteFinder搜索吸附位点" class="headerlink" title="AdsorbateSiteFinder搜索吸附位点"></a>AdsorbateSiteFinder搜索吸附位点</h3><p><code>AdsorbateSiteFinder</code>模块主要用于搜索<code>slab</code>模型表面潜在的吸附位点，主要分为三大类：<code>ontop</code>、<code>bridge</code>、<code>hollow</code>。首先导入<code>AdsorbateSiteFinder</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder</span><br></pre></td></tr></table></figure>

<p><code>slab</code>模型以<code>Si(111)</code>面为例，关于如何自动切<code>slab</code>模型可以参考往期内容。</p>
<p>模型：</p>
<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240806174304659.png" alt="image-20240806174304659"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">Si_111 = Structure.from_file(<span class="string">&quot;./Si_111.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">asf = AdsorbateSiteFinder(Si_111)</span><br><span class="line"><span class="comment"># 搜索吸附位点</span></span><br><span class="line">adsorption_sites = asf.find_adsorption_sites()</span><br></pre></td></tr></table></figure>

<p>调用<code>find_adsorption_sites()</code>方法搜索吸附位点，<code>find_adsorption_sites()</code>默认的吸附距离为2埃。可以传入<code>distance</code>参数进行覆盖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">Si_111 = Structure.from_file(<span class="string">&quot;./Si_111.cif&quot;</span>)</span><br><span class="line"><span class="comment"># 3x3x1超胞</span></span><br><span class="line">Si_111.make_supercell([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">asf = AdsorbateSiteFinder(Si_111)</span><br><span class="line"><span class="comment"># 搜索吸附位点</span></span><br><span class="line">adsorption_sites = asf.find_adsorption_sites()</span><br><span class="line"><span class="comment"># 打印吸附位点</span></span><br><span class="line">pprint(adsorption_sites)</span><br></pre></td></tr></table></figure>

<p>运行代码，可以得到所有潜在吸附位点的坐标：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;all&#x27;: [array([ 3.36811902,  0.27779776, 28.32198049]),</span><br><span class="line">         array([12.02899646, 15.27887752, 28.32198049]),</span><br><span class="line">         array([11.06667674, 15.83447306, 28.32198049]),</span><br><span class="line">         array([ 9.14203731, 14.72328197, 28.32198049])],</span><br><span class="line"> &#x27;bridge&#x27;: [array([12.02899646, 15.27887752, 28.32198049])],</span><br><span class="line"> &#x27;hollow&#x27;: [array([11.06667674, 15.83447306, 28.32198049]),</span><br><span class="line">            array([ 9.14203731, 14.72328197, 28.32198049])],</span><br><span class="line"> &#x27;ontop&#x27;: [array([ 3.36811902,  0.27779776, 28.32198049])]&#125;</span><br></pre></td></tr></table></figure>

<p>初次之外，还可以导入<code>plot_slab()</code>方法实现可视化，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder, plot_slab	</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">Si_111 = Structure.from_file(<span class="string">&quot;./Si_111.cif&quot;</span>)</span><br><span class="line"><span class="comment"># 3x3x1超胞</span></span><br><span class="line">Si_111.make_supercell([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">asf = AdsorbateSiteFinder(Si_111)</span><br><span class="line"><span class="comment"># 搜索吸附位点</span></span><br><span class="line">adsorption_sites = asf.find_adsorption_sites()</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plot_slab(slab, ax=fig.add_subplot(<span class="number">111</span>), adsorption_sites=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><code>plot_slab()</code>主要需要传入三个参数：</p>
<ul>
<li><code>slab</code>：表面模型</li>
<li><code>ax</code>：<code>matplotlib</code>对象用于绘图</li>
<li><code>adsorption_sites</code>：是否显示吸附位点标识</li>
</ul>
<p>运行代码后可得到：</p>
<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240806175532022.png" alt="image-20240806175532022"></p>
<p>深色表示最表层原子，浅色表示次表层原子；平行四边形框表示<code>3x3x1</code>超胞的<code>Si_111</code>结构，<code>X</code>表示对应的潜在吸附位点。</p>
<h3 id="添加吸附原子-分子"><a href="#添加吸附原子-分子" class="headerlink" title="添加吸附原子&#x2F;分子"></a>添加吸附原子&#x2F;分子</h3><p>搜索完吸附位点后，下一步需要给<code>slab</code>增加吸附的原子&#x2F;分子，最直接的方法为直接写对应的原子分子坐标，然后传入，以吸附<code>CO</code>为例，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder, plot_slab</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Molecule</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">Si_111 = Structure.from_file(<span class="string">&quot;./Si_111.cif&quot;</span>)</span><br><span class="line"><span class="comment"># 3x3x1超胞</span></span><br><span class="line">Si_111.make_supercell([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">asf = AdsorbateSiteFinder(Si_111)</span><br><span class="line"><span class="comment"># 搜索吸附位点</span></span><br><span class="line">adsorption_sites = asf.find_adsorption_sites()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建CO分子</span></span><br><span class="line">CO = Molecule((<span class="string">&quot;C&quot;</span>,<span class="string">&quot;O&quot;</span>), [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1.128</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 生成吸附结构</span></span><br><span class="line">absorbed_structure = asf.add_adsorbate(molecule=CO, ads_coord=adsorption_sites[<span class="string">&#x27;hollow&#x27;</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plot_slab(absorbed_structure, ax=fig.add_subplot(<span class="number">111</span>), adsorption_sites=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>首先，该方法先要导入<code>Molecule</code>模块，<code>Molecule</code>仅需要传入，原子元素种类及对应的坐标，且一一对应。这里传入的坐标对应的空间与<code>slab</code>模型无关，可以认为是在一个空盒子里面构建分子。</p>
<p>然后，调用<code>AdsorbateSiteFinder</code>模块的<code>add_adsorbate()</code>方法把吸附分子加在<code>slab</code>上。</p>
<p><code>add_adsorbate()</code>需要读取分子结构<code>molecule=CO</code>，以及吸附坐标<code>ads_coord=adsorption_sites[&#39;hollow&#39;][0]</code>，这里坐标选取第一个<code>hollow</code>位。</p>
<p>运行代码：</p>
<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240807094308680.png" alt="image-20240807094308680"></p>
<p>结果显示<code>CO</code>的吸附情况，可以导出<code>cif</code>结构查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">absorbed_structure = asf.add_adsorbate(molecule=CO, ads_coord=adsorption_sites[<span class="string">&#x27;hollow&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">absorbed_structure.to(<span class="string">&#x27;./Si111_CO.cif&#x27;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>VESTA</code>查看：</p>
<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240807094552480.png" alt="image-20240807094552480"></p>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>上述操作中，如果每次吸附分子都需要自己写坐标的话，确实会比较麻烦。对于复杂的分子，自己写坐标的难度也比较大。</p>
<p>因此，这里推荐调用<code>ase</code>来自动导入分子结构，主要用到的模块为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build.molecule <span class="keyword">import</span> molecule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建CO分子</span></span><br><span class="line">CO = molecule(<span class="string">&quot;CO&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>ase</code>的<code>molecule</code>模块支持输入常见的分子化学式就可以构建对应的分子结构，可以通过如下代码查看支持的分子种类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build.molecule <span class="keyword">import</span> extra</span><br><span class="line"><span class="keyword">from</span> ase.collections <span class="keyword">import</span> g2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g2.names)</span><br><span class="line"><span class="built_in">print</span>(extra.keys())</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[&#x27;PH3&#x27;, &#x27;P2&#x27;, &#x27;CH3CHO&#x27;, &#x27;H2COH&#x27;, &#x27;CS&#x27;, &#x27;OCHCHO&#x27;, &#x27;C3H9C&#x27;, &#x27;CH3COF&#x27;, &#x27;CH3CH2OCH3&#x27;, &#x27;HCOOH&#x27;, &#x27;HCCl3&#x27;, &#x27;HOCl&#x27;, &#x27;H2&#x27;, &#x27;SH2&#x27;, &#x27;C2H2&#x27;, &#x27;C4H4NH&#x27;, &#x27;CH3SCH3&#x27;, &#x27;SiH2<span class="built_in">_</span>s3B1d&#x27;, &#x27;CH3SH&#x27;, &#x27;CH3CO&#x27;, &#x27;CO&#x27;, &#x27;ClF3&#x27;, &#x27;SiH4&#x27;, &#x27;C2H6CHOH&#x27;, &#x27;CH2NHCH2&#x27;, &#x27;isobutene&#x27;, &#x27;HCO&#x27;, &#x27;bicyclobutane&#x27;, &#x27;LiF&#x27;, &#x27;Si&#x27;, &#x27;C2H6&#x27;, &#x27;CN&#x27;, &#x27;ClNO&#x27;, &#x27;S&#x27;, &#x27;SiF4&#x27;, &#x27;H3CNH2&#x27;, &#x27;methylenecyclopropane&#x27;, &#x27;CH3CH2OH&#x27;, &#x27;F&#x27;, &#x27;NaCl&#x27;, &#x27;CH3Cl&#x27;, &#x27;CH3SiH3&#x27;, &#x27;AlF3&#x27;, &#x27;C2H3&#x27;, &#x27;ClF&#x27;, &#x27;PF3&#x27;, &#x27;PH2&#x27;, &#x27;CH3CN&#x27;, &#x27;cyclobutene&#x27;, &#x27;CH3ONO&#x27;, &#x27;SiH3&#x27;, &#x27;C3H6<span class="built_in">_</span>D3h&#x27;, &#x27;CO2&#x27;, &#x27;NO&#x27;, &#x27;trans-butane&#x27;, &#x27;H2CCHCl&#x27;, &#x27;LiH&#x27;, &#x27;NH2&#x27;, &#x27;CH&#x27;, &#x27;CH2OCH2&#x27;, &#x27;C6H6&#x27;, &#x27;CH3CONH2&#x27;, &#x27;cyclobutane&#x27;, &#x27;H2CCHCN&#x27;, &#x27;butadiene&#x27;, &#x27;C&#x27;, &#x27;H2CO&#x27;, &#x27;CH3COOH&#x27;, &#x27;HCF3&#x27;, &#x27;CH3S&#x27;, &#x27;CS2&#x27;, &#x27;SiH2<span class="built_in">_</span>s1A1d&#x27;, &#x27;C4H4S&#x27;, &#x27;N2H4&#x27;, &#x27;OH&#x27;, &#x27;CH3OCH3&#x27;, &#x27;C5H5N&#x27;, &#x27;H2O&#x27;, &#x27;HCl&#x27;, &#x27;CH2<span class="built_in">_</span>s1A1d&#x27;, &#x27;CH3CH2SH&#x27;, &#x27;CH3NO2&#x27;, &#x27;Cl&#x27;, &#x27;Be&#x27;, &#x27;BCl3&#x27;, &#x27;C4H4O&#x27;, &#x27;Al&#x27;, &#x27;CH3O&#x27;, &#x27;CH3OH&#x27;, &#x27;C3H7Cl&#x27;, &#x27;isobutane&#x27;, &#x27;Na&#x27;, &#x27;CCl4&#x27;, &#x27;CH3CH2O&#x27;, &#x27;H2CCHF&#x27;, &#x27;C3H7&#x27;, &#x27;CH3&#x27;, &#x27;O3&#x27;, &#x27;P&#x27;, &#x27;C2H4&#x27;, &#x27;NCCN&#x27;, &#x27;S2&#x27;, &#x27;AlCl3&#x27;, &#x27;SiCl4&#x27;, &#x27;SiO&#x27;, &#x27;C3H4<span class="built_in">_</span>D2d&#x27;, &#x27;H&#x27;, &#x27;COF2&#x27;, &#x27;2-butyne&#x27;, &#x27;C2H5&#x27;, &#x27;BF3&#x27;, &#x27;N2O&#x27;, &#x27;F2O&#x27;, &#x27;SO2&#x27;, &#x27;H2CCl2&#x27;, &#x27;CF3CN&#x27;, &#x27;HCN&#x27;, &#x27;C2H6NH&#x27;, &#x27;OCS&#x27;, &#x27;B&#x27;, &#x27;ClO&#x27;, &#x27;C3H8&#x27;, &#x27;HF&#x27;, &#x27;O2&#x27;, &#x27;SO&#x27;, &#x27;NH&#x27;, &#x27;C2F4&#x27;, &#x27;NF3&#x27;, &#x27;CH2<span class="built_in">_</span>s3B1d&#x27;, &#x27;CH3CH2Cl&#x27;, &#x27;CH3COCl&#x27;, &#x27;NH3&#x27;, &#x27;C3H9N&#x27;, &#x27;CF4&#x27;, &#x27;C3H6<span class="built_in">_</span>Cs&#x27;, &#x27;Si2H6&#x27;, &#x27;HCOOCH3&#x27;, &#x27;O&#x27;, &#x27;CCH&#x27;, &#x27;N&#x27;, &#x27;Si2&#x27;, &#x27;C2H6SO&#x27;, &#x27;C5H8&#x27;, &#x27;H2CF2&#x27;, &#x27;Li2&#x27;, &#x27;CH2SCH2&#x27;, &#x27;C2Cl4&#x27;, &#x27;C3H4<span class="built_in">_</span>C3v&#x27;, &#x27;CH3COCH3&#x27;, &#x27;F2&#x27;, &#x27;CH4&#x27;, &#x27;SH&#x27;, &#x27;H2CCO&#x27;, &#x27;CH3CH2NH2&#x27;, &#x27;Li&#x27;, &#x27;N2&#x27;, &#x27;Cl2&#x27;, &#x27;H2O2&#x27;, &#x27;Na2&#x27;, &#x27;BeH&#x27;, &#x27;C3H4<span class="built_in">_</span>C2v&#x27;, &#x27;NO2&#x27;]</span><br><span class="line">dict<span class="built_in">_</span>keys([&#x27;Be2&#x27;, &#x27;C7NH5&#x27;, &#x27;BDA&#x27;, &#x27;biphenyl&#x27;, &#x27;C60&#x27;])</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>：<code>ase</code>得到的分子结构不能直接使用，还需要转化成pymatgen可以读取的格式，需要用到<code>AseAtomsAdaptor</code>，完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build.molecule <span class="keyword">import</span> molecule</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.ase <span class="keyword">import</span> AseAtomsAdaptor</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> AdsorbateSiteFinder, plot_slab</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">Si_111 = Structure.from_file(<span class="string">&quot;./Si_111.cif&quot;</span>)</span><br><span class="line"><span class="comment"># 3x3x1超胞</span></span><br><span class="line">Si_111.make_supercell([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">asf = AdsorbateSiteFinder(Si_111)</span><br><span class="line"><span class="comment"># 搜索吸附位点</span></span><br><span class="line">adsorption_sites = asf.find_adsorption_sites()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ase创建CO分子</span></span><br><span class="line">CO = molecule(<span class="string">&quot;CO&quot;</span>)</span><br><span class="line"><span class="comment"># 转化成pymatgen格式</span></span><br><span class="line">pmg_CO = AseAtomsAdaptor.get_molecule(CO)</span><br><span class="line"><span class="comment"># 生成吸附结构</span></span><br><span class="line">absorbed_structure = asf.add_adsorbate(molecule=pmg_CO, ads_coord=adsorption_sites[<span class="string">&#x27;hollow&#x27;</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plot_slab(absorbed_structure, ax=fig.add_subplot(<span class="number">111</span>), adsorption_sites=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240807095933965.png" alt="image-20240807095933965"></p>
<p>导出cif文件在<code>VESTA</code>查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">absorbed_structure = asf.add_adsorbate(molecule=pmg_CO, ads_coord=adsorption_sites[<span class="string">&#x27;hollow&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">absorbed_structure.to(<span class="string">&#x27;./Si111_CO_new.cif&#x27;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/07/Learn-VASP-from-pymatgen-13/image-20240807100101988.png" alt="image-20240807100101988"></p>
<p><strong>Note</strong>：对比两种方法可以发现，<code>ase</code>中的<code>CO</code>分子默认是垂直吸附。该方法的缺点即无法自定义吸附姿态，如果需要自定义吸附姿态，还是需要自己写坐标，或者其他软件建模导入。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.11  计算小白硬学VASP —— 构建slab模型</title>
    <url>/2024/08/05/Learn-VASP-from-pymatgen-11/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何构建<code>slab</code>模型。</p>
<p>首先切面用到的<code>miller index</code>针对的是<code>bulk</code>模型的惯用胞（<code>conventional cell</code>）而不是原胞（<code>primtive cell</code>），这与之前计算能带是刚好相反的。</p>
<p>所以，在进行切面操作时，要确保你的<code>bulk</code>模型是惯用胞，可以用<code>pymatgen</code>的功能来帮助实现。</p>
<ul>
<li>直接从<code>Materials project</code>下载结构</li>
</ul>
<p>如果是从<code>MP</code>上下载结构，我们需要把<code>conventional_cell = True</code>打开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;your key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    Si = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>,conventional_unit_cell=<span class="literal">True</span>)</span><br><span class="line">    Si.to(filename=<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样确保你下载的结构是惯用胞。</p>
<ul>
<li>原胞转化为惯用胞</li>
</ul>
<p>也可以通过转化来确保使用的是惯用胞：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"></span><br><span class="line">structure = Structure.from_file(<span class="string">&quot;./Si_primtive.cif&quot;</span>)</span><br><span class="line">analyzer = SpacegroupAnalyzer(structure)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;old structure: \n <span class="subst">&#123;structure&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">new_structure = analyzer.get_conventional_standard_structure()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;new structure: \n <span class="subst">&#123;new_structure&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>new_structure</code>对应的就是惯用胞结构。运行代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">old structure: </span><br><span class="line"> Full Formula (Si2)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   3.849278   3.849279   3.849278</span><br><span class="line">angles:  60.000012  60.000003  60.000011</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (2)</span><br><span class="line">  #  SP        a      b      c</span><br><span class="line">---  ----  -----  -----  -----</span><br><span class="line">  0  Si    0.875  0.875  0.875</span><br><span class="line">  1  Si    0.125  0.125  0.125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new structure: </span><br><span class="line"> Full Formula (Si8)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  #  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  Si    0.75  0.75  0.25</span><br><span class="line">  1  Si    0     0.5   0.5</span><br><span class="line">  2  Si    0.75  0.25  0.75</span><br><span class="line">  3  Si    0     0     0</span><br><span class="line">  4  Si    0.25  0.75  0.75</span><br><span class="line">  5  Si    0.5   0.5   0</span><br><span class="line">  6  Si    0.25  0.25  0.25</span><br><span class="line">  7  Si    0.5   0     0.5</span><br></pre></td></tr></table></figure>

<p>或者你不知道自己的结构到底是原胞还是惯用胞，可以无脑直接转换，因为对于本身就是惯用胞的结构，<code>get_conventional_standard_structure()</code>方法不会修改本身的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取本身是惯用胞的结构</span></span><br><span class="line">structure = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line">analyzer = SpacegroupAnalyzer(structure)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;old structure: \n <span class="subst">&#123;structure&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">new_structure = analyzer.get_conventional_standard_structure()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;new structure: \n <span class="subst">&#123;new_structure&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果不变，运行代码：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">old structure: </span><br><span class="line"> Full Formula (Si8)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  #  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  Si    0.75  0.75  0.25</span><br><span class="line">  1  Si    0     0.5   0.5</span><br><span class="line">  2  Si    0.75  0.25  0.75</span><br><span class="line">  3  Si    0     0     0</span><br><span class="line">  4  Si    0.25  0.75  0.75</span><br><span class="line">  5  Si    0.5   0.5   0</span><br><span class="line">  6  Si    0.25  0.25  0.25</span><br><span class="line">  7  Si    0.5   0     0.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new structure: </span><br><span class="line"> Full Formula (Si8)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  #  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  Si    0.25  0.75  0.75</span><br><span class="line">  1  Si    0     0     0</span><br><span class="line">  2  Si    0.25  0.25  0.25</span><br><span class="line">  3  Si    0     0.5   0.5</span><br><span class="line">  4  Si    0.75  0.75  0.25</span><br><span class="line">  5  Si    0.5   0     0.5</span><br><span class="line">  6  Si    0.75  0.25  0.75</span><br><span class="line">  7  Si    0.5   0.5   0</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>：上述方法对于缺陷结构和掺杂结构，由于对称性无法识别可能无法转化。</p>
<h3 id="SlabGenerator模块"><a href="#SlabGenerator模块" class="headerlink" title="SlabGenerator模块"></a>SlabGenerator模块</h3><p>进入正题，切面主要用到<code>pyamtgen</code>的<code>SlabGenerator</code>模块，首先导入它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.surface <span class="keyword">import</span> SlabGenerator</span><br></pre></td></tr></table></figure>

<p>然后需要先实例化<code>SlabGenetator</code>，才能调用里面的切面方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.surface <span class="keyword">import</span> SlabGenerator</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">Si = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">slabgen = SlabGenerator(</span><br><span class="line">    initial_structure=Si,		<span class="comment"># 初始结构</span></span><br><span class="line">    miller_index=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),		<span class="comment"># 指定晶面</span></span><br><span class="line">    min_slab_size=<span class="number">15</span>,			<span class="comment"># slab厚度</span></span><br><span class="line">    min_vacuum_size=<span class="number">20</span>,			<span class="comment"># 真空层厚度</span></span><br><span class="line">    in_unit_planes=<span class="literal">False</span>,		<span class="comment"># 切换 min_slab_size &amp; min_vacuum_size</span></span><br><span class="line">    center_slab=<span class="literal">True</span>,			<span class="comment"># slab模型居中</span></span><br><span class="line">    primitive=<span class="literal">True</span>,				<span class="comment"># 使用最小切面结构</span></span><br><span class="line">    reorient_lattice=<span class="literal">True</span>,		<span class="comment"># 重定向晶格</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里着重介绍<code>in_unit_planes</code>和<code>primitive</code>参数。</p>
<ul>
<li><p><code>in_unit_planes</code>：影响<code>min_slab_size</code>和<code>min_vacuum_size</code>的数值，默认为<code>False</code>。</p>
<ul>
<li><p>当为<code>False</code>时，<code>min_slab_size</code>和<code>min_vacuum_size</code>对应的单位为<code>Angstrom </code>，即上述分别表示<code>slab</code>厚度为10埃，真空层厚度为15埃；</p>
</li>
<li><p>当为<code>True</code>时，数值为切面的层数，如此时<code>min_slab_size</code>和<code>min_vacuum_size</code>都设置为3，表示slab厚度和真空层厚度为(1,1,1)面最小重复单元乘以3。需要注意的是，此时数字<code>3</code>并不等于原子层数，且不同晶面的最小重复单元的厚度不一样，如<code>Si</code>的(1,1,1)面单层厚度是小于(1,0,0)面的。</p>
</li>
</ul>
</li>
<li><p><code>primitive</code>：默认为True。该参数跟<code>primitive cell</code>没有关系，在这里是决定<code>slab</code>结构是否选取最小单元。当设置为<code>True</code>时，如1x1x1的<code>Si</code>惯用胞结构和3x3x3超胞的<code>Si</code>惯用胞结构，最后得到的<code>slab</code>结构是一样。</p>
</li>
</ul>
<p><code>SlabGenerator</code>下面有许多切面的方法，下面一一介绍。</p>
<h4 id="get-slab-方法"><a href="#get-slab-方法" class="headerlink" title="get_slab()方法"></a>get_slab()方法</h4><p><code>get_slab()</code>方法用于生成指定暴露面原子的<code>slab</code>结构，传入<code>shift</code>参数来指定原子。该方法不建议直接使用，前提你需要确定shift的值。对于垂直于坐标轴的切面，<code>shift</code>值对应的分别就是abc的坐标，但是其他晶面情况就需要简单的运算之后才能够得到<code>shift</code>值。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.surface <span class="keyword">import</span> SlabGenerator</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">Si = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line">slabgen = SlabGenerator(</span><br><span class="line">    initial_structure=Si,</span><br><span class="line">    miller_index=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    min_slab_size=<span class="number">15</span>,</span><br><span class="line">    min_vacuum_size=<span class="number">20</span>,</span><br><span class="line">    in_unit_planes=<span class="literal">False</span>,</span><br><span class="line">    center_slab=<span class="literal">True</span>,</span><br><span class="line">    primitive=<span class="literal">True</span>,</span><br><span class="line">    reorient_lattice=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 生成表面</span></span><br><span class="line">slab = slabgen.get_slab(shift=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 保存结构</span></span><br><span class="line">slab.to(<span class="string">&quot;./Si_111_getslab.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>vesta</code>里面查看结构：</p>
<p><img src="/2024/08/05/Learn-VASP-from-pymatgen-11/image-20240805095256547.png" alt="image-20240805095256547"></p>
<p><code>slab</code>厚度和真空层厚度可根据上述方法自行调整。</p>
<h4 id="get-slabs-方法"><a href="#get-slabs-方法" class="headerlink" title="get_slabs()方法"></a>get_slabs()方法</h4><p><code>get_slabs()</code>支持生成所有符合要求的<code>slab</code>，接受传入的参数也要比<code>gen_slab()</code>多，主要有：</p>
<ul>
<li><code>bonds</code>：设置成键范围。通俗的讲就是保护指定原子键对，避免断键。如<code>LiFePO4</code>中要保护<code>PO4</code>基团不被切断键，可以设置<code>bonds=&#123;(“P”, “O”): 3&#125;</code>，这样就告诉<code>pymatgen</code>，3埃范围内的<code>P</code>原子和<code>O</code>原子维持成键，切面时就会避开<code>PO4</code>断键了。</li>
<li><code>max_broken_bonds</code>：自动切表面时，最大断键数，默认为0。建议不要主动设置，对于复杂结构，会导致切出的<code>slabs</code>数量急增。</li>
<li><code>repair</code>：自动补齐暴露面断键原子，默认<code>False</code>。也建议不要设置，会生成许多不可理的结构。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.surface <span class="keyword">import</span> SlabGenerator</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">Si = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line">slabgen = SlabGenerator(</span><br><span class="line">    initial_structure=Si,</span><br><span class="line">    miller_index=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    min_slab_size=<span class="number">15</span>,</span><br><span class="line">    min_vacuum_size=<span class="number">20</span>,</span><br><span class="line">    in_unit_planes=<span class="literal">False</span>,</span><br><span class="line">    center_slab=<span class="literal">True</span>,</span><br><span class="line">    primitive=<span class="literal">True</span>,</span><br><span class="line">    reorient_lattice=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 生成所有表面</span></span><br><span class="line">slabs = slabgen.get_slabs()</span><br><span class="line"><span class="comment"># 打印结构信息</span></span><br><span class="line"><span class="built_in">print</span>([slab <span class="keyword">for</span> slab <span class="keyword">in</span> slabs])</span><br><span class="line"><span class="comment"># 保存结构</span></span><br><span class="line"><span class="keyword">for</span> i, slab <span class="keyword">in</span> <span class="built_in">enumerate</span>(slabs):</span><br><span class="line">    slab.to(<span class="string">f&quot;Si_111_getslabs_<span class="subst">&#123;i&#125;</span>.cif&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[Structure Summary</span><br><span class="line">Lattice</span><br><span class="line">    abc : 3.8492788605882793 3.8492788605882797 37.715076344492445</span><br><span class="line"> angles : 90.0 90.0 120.00000000000001</span><br><span class="line"> volume : 483.9543213850744</span><br><span class="line">      A : 3.8492788605882793 0.0 2.3570035178225037e-16</span><br><span class="line">      B : -1.9246394302941412 3.333573279519868 2.3570035178225037e-16</span><br><span class="line">      C : 0.0 0.0 37.715076344492445</span><br><span class="line">    pbc : True True True</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 12.18) [0.9167, 0.08333, 0.3229]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 12.96) [0.25, 0.75, 0.3438]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 15.32) [0.25, 0.75, 0.4063]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 16.11) [0.5833, 0.4167, 0.4271]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 18.46) [0.5833, 0.4167, 0.4896]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 19.25) [0.9167, 0.08333, 0.5104]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 21.61) [0.9167, 0.08333, 0.5729]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 22.39) [0.25, 0.75, 0.5938]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 24.75) [0.25, 0.75, 0.6563]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 25.54) [0.5833, 0.4167, 0.6771], </span><br><span class="line"></span><br><span class="line">Structure Summary</span><br><span class="line">Lattice</span><br><span class="line">    abc : 3.8492788605882793 3.8492788605882797 37.715076344492445</span><br><span class="line"> angles : 90.0 90.0 120.00000000000001</span><br><span class="line"> volume : 483.9543213850744</span><br><span class="line">      A : 3.8492788605882793 0.0 2.3570035178225037e-16</span><br><span class="line">      B : -1.9246394302941412 3.333573279519868 2.3570035178225037e-16</span><br><span class="line">      C : 0.0 0.0 37.715076344492445</span><br><span class="line">    pbc : True True True</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 13.75) [0.5833, 0.4167, 0.3646]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 11.39) [0.5833, 0.4167, 0.3021]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 16.89) [0.9167, 0.08333, 0.4479]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 14.54) [0.9167, 0.08333, 0.3854]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 20.04) [0.25, 0.75, 0.5313]</span><br><span class="line">PeriodicSite: Si (-0.4812, 2.5, 17.68) [0.25, 0.75, 0.4688]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 23.18) [0.5833, 0.4167, 0.6146]</span><br><span class="line">PeriodicSite: Si (1.443, 1.389, 20.82) [0.5833, 0.4167, 0.5521]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 26.32) [0.9167, 0.08333, 0.6979]</span><br><span class="line">PeriodicSite: Si (3.368, 0.2778, 23.96) [0.9167, 0.08333, 0.6354]]</span><br></pre></td></tr></table></figure>

<p><code>get_slabs()</code>自动切出所有的表面，根据输出信息可以发现根据原子排布不同<code>Si</code>(1,1,1)面有两种暴露面：</p>
<p><img src="/2024/08/05/Learn-VASP-from-pymatgen-11/image-20240805102203787.png" alt="image-20240805102203787"></p>
<p><img src="/2024/08/05/Learn-VASP-from-pymatgen-11/image-20240805102215172.png" alt="image-20240805102215172"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>pymatgen</code>切面有时候<code>slab</code>c方向不是正交的，即γ角不为90°。此时可以调用<code>get_orthogonal_c_slab()</code>方法进行矫正即可，用法为直接在<code>slab</code>对象调用即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># SlabGenerator生成表面</span></span><br><span class="line">slab = slabgen.get_slab()</span><br><span class="line"><span class="comment"># 正交转化</span></span><br><span class="line">slab.get_orthogonal_c_slab()</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.14  计算小白硬学VASP —— 各类结构“Transformation”使用说明（一）</title>
    <url>/2024/08/09/Learn-VASP-from-pymatgen-14/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章开始，主要介绍<code>pymatgen</code>中<code>standard_transformations</code>中各类<code>Transformation</code>的使用说明。</p>
<h3 id="AutoOxiStateDecorationTransformation"><a href="#AutoOxiStateDecorationTransformation" class="headerlink" title="AutoOxiStateDecorationTransformation"></a>AutoOxiStateDecorationTransformation</h3><p>该类主要是自动平衡结构中的价态信息，以<code>LiFePO4</code>结构为例，初始结构信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">LFP = Structure.from_file(<span class="string">&quot;./LiFePO4.vasp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(LFP)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Full Formula (Li4 Fe4 P4 O16)</span><br><span class="line">Reduced Formula: LiFePO4</span><br><span class="line">abc   :   4.654917   5.970755  10.236196</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP           a         b         c</span><br><span class="line">---  ----  --------  --------  --------</span><br><span class="line">  0  Li    0         0         0</span><br><span class="line">  1  Li    0.5       0.5       0.5</span><br><span class="line">  2  Li    0.5       0         0.5</span><br><span class="line">  3  Li    0         0.5       0</span><br><span class="line">  4  Fe    0.529866  0.25      0.781151</span><br><span class="line">  5  Fe    0.029866  0.75      0.718849</span><br><span class="line">  6  Fe    0.970134  0.25      0.281151</span><br><span class="line">  7  Fe    0.470134  0.75      0.218849</span><br><span class="line">  8  P     0.418623  0.25      0.093866</span><br><span class="line">  9  P     0.918623  0.75      0.406134</span><br><span class="line"> 10  P     0.081377  0.25      0.593866</span><br><span class="line"> 11  P     0.581377  0.75      0.906134</span><br><span class="line"> 12  O     0.744787  0.25      0.094231</span><br><span class="line"> 13  O     0.713735  0.545558  0.834155</span><br><span class="line"> 14  O     0.713735  0.954442  0.834155</span><br><span class="line"> 15  O     0.255213  0.75      0.905769</span><br><span class="line"> 16  O     0.709864  0.75      0.044309</span><br><span class="line"> 17  O     0.244787  0.75      0.405769</span><br><span class="line"> 18  O     0.286265  0.045558  0.165845</span><br><span class="line"> 19  O     0.213735  0.454442  0.665845</span><br><span class="line"> 20  O     0.786265  0.545558  0.334155</span><br><span class="line"> 21  O     0.786265  0.954442  0.334155</span><br><span class="line"> 22  O     0.290136  0.25      0.955691</span><br><span class="line"> 23  O     0.209864  0.25      0.455691</span><br><span class="line"> 24  O     0.790136  0.75      0.544309</span><br><span class="line"> 25  O     0.755213  0.25      0.594231</span><br><span class="line"> 26  O     0.213735  0.045558  0.665845</span><br><span class="line"> 27  O     0.286265  0.454442  0.165845</span><br></pre></td></tr></table></figure>

<p>此时结构信息中只包含元素种类及原子坐标。</p>
<p>调用<code>AutoOxiStateDecorationTransformation</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> AutoOxiStateDecorationTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">LFP = Structure.from_file(<span class="string">&quot;./LiFePO4.vasp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">transformation = AutoOxiStateDecorationTransformation()</span><br><span class="line">new_LFP = transformation.apply_transformation(LFP)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(new_LFP)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Full Formula (Li4 Fe4 P4 O16)</span><br><span class="line">Reduced Formula: LiFePO4</span><br><span class="line">abc   :   4.654917   5.970755  10.236196</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP           a         b         c</span><br><span class="line">---  ----  --------  --------  --------</span><br><span class="line">  0  Li+   0         0         0</span><br><span class="line">  1  Li+   0.5       0.5       0.5</span><br><span class="line">  2  Li+   0.5       0         0.5</span><br><span class="line">  3  Li+   0         0.5       0</span><br><span class="line">  4  Fe2+  0.529866  0.25      0.781151</span><br><span class="line">  5  Fe2+  0.029866  0.75      0.718849</span><br><span class="line">  6  Fe2+  0.970134  0.25      0.281151</span><br><span class="line">  7  Fe2+  0.470134  0.75      0.218849</span><br><span class="line">  8  P5+   0.418623  0.25      0.093866</span><br><span class="line">  9  P5+   0.918623  0.75      0.406134</span><br><span class="line"> 10  P5+   0.081377  0.25      0.593866</span><br><span class="line"> 11  P5+   0.581377  0.75      0.906134</span><br><span class="line"> 12  O2-   0.744787  0.25      0.094231</span><br><span class="line"> 13  O2-   0.713735  0.545558  0.834155</span><br><span class="line"> 14  O2-   0.713735  0.954442  0.834155</span><br><span class="line"> 15  O2-   0.255213  0.75      0.905769</span><br><span class="line"> 16  O2-   0.709864  0.75      0.044309</span><br><span class="line"> 17  O2-   0.244787  0.75      0.405769</span><br><span class="line"> 18  O2-   0.286265  0.045558  0.165845</span><br><span class="line"> 19  O2-   0.213735  0.454442  0.665845</span><br><span class="line"> 20  O2-   0.786265  0.545558  0.334155</span><br><span class="line"> 21  O2-   0.786265  0.954442  0.334155</span><br><span class="line"> 22  O2-   0.290136  0.25      0.955691</span><br><span class="line"> 23  O2-   0.209864  0.25      0.455691</span><br><span class="line"> 24  O2-   0.790136  0.75      0.544309</span><br><span class="line"> 25  O2-   0.755213  0.25      0.594231</span><br><span class="line"> 26  O2-   0.213735  0.045558  0.665845</span><br><span class="line"> 27  O2-   0.286265  0.454442  0.165845</span><br></pre></td></tr></table></figure>

<p>此时可以发现对应的元素符号之后多了化合价信息。</p>
<p><code>VASP</code>计算磁性材料时，初始磁矩的设置直接影响到计算过程的收敛快慢以及最终的能量。该类的用法在实际计算中可以为我们计算磁矩信息提供一个合理的初猜值，便于更好的自定义<code>MAGMOM</code>参数。</p>
<h3 id="ChargedCellTransformation"><a href="#ChargedCellTransformation" class="headerlink" title="ChargedCellTransformation"></a>ChargedCellTransformation</h3><p>该类主要给结构施加额外电荷，使体系整体带正电或者负电。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> ChargedCellTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">LFP = Structure.from_file(<span class="string">&quot;./LiFePO4.vasp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(LFP)</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">transformation = ChargedCellTransformation(charge=<span class="number">2</span>)</span><br><span class="line">new_LFP = transformation.apply_transformation(LFP)</span><br><span class="line"><span class="built_in">print</span>(new_LFP)</span><br></pre></td></tr></table></figure>

<p><code>ChargedCellTransformation</code>实例化时传入<code>charge</code>参数来确定体系带电情况。</p>
<p>部分输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">LFP：</span><br><span class="line">Full Formula (Li4 Mn1 Fe3 P4 O16)</span><br><span class="line">Reduced Formula: Li4MnFe3(PO4)4</span><br><span class="line">abc   :   4.654917   5.970755  10.236196</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line"></span><br><span class="line">new<span class="built_in">_</span>LFP:</span><br><span class="line">Full Formula (Li4 Mn1 Fe3 P4 O16)</span><br><span class="line">Reduced Formula: Li4MnFe3(PO4)4</span><br><span class="line">abc   :   4.654917   5.970755  10.236196</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Overall Charge: +2	<span class="params">#</span> 体系带正电</span><br><span class="line">Sites (28)</span><br></pre></td></tr></table></figure>

<p><code>Overall Charge: +2</code>说明给体系加了两个正电荷。</p>
<p>怎么在计算中体现带电情况呢？在之前直接调用<code>MPRelaxSet</code>的基础上有一点点变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> ChargedCellTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br><span class="line"></span><br><span class="line">LFP = Structure.from_file(<span class="string">&quot;./LiFePO4.vasp&quot;</span>)</span><br><span class="line"></span><br><span class="line">transformation = ChargedCellTransformation(charge=<span class="number">2</span>)</span><br><span class="line">new_LFP = transformation.apply_transformation(LFP)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">old_set = MPRelaxSet(LFP, use_structure_charge=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;不带电体系INCAR：\n<span class="subst">&#123;old_set.incar&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_set = MPRelaxSet(new_LFP, use_structure_charge=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;带电体系INCAR：\n<span class="subst">&#123;new_set.incar&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先，在调用<code>MPRelaxSet</code>的时候需要设置<code>use_structure_charge=True</code>，这样才读取的是结构中的电荷信息，反之则采用默认的设置。</p>
<p>代码部分输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">不带电体系INCAR：</span><br><span class="line">......</span><br><span class="line">MAGMOM = 4*0.6 4*5.0 20*0.6</span><br><span class="line">NELECT = 183.0</span><br><span class="line">NELM = 100</span><br><span class="line">NSW = 99</span><br><span class="line">PREC = Accurate</span><br><span class="line">SIGMA = 0.05</span><br><span class="line"></span><br><span class="line">带电体系INCAR：</span><br><span class="line">......</span><br><span class="line">MAGMOM = 4*0.6 4*5.0 20*0.6</span><br><span class="line">NELECT = 181.0</span><br><span class="line">NELM = 100</span><br><span class="line">NSW = 99</span><br><span class="line">PREC = Accurate</span><br><span class="line">SIGMA = 0.05</span><br></pre></td></tr></table></figure>

<p>对比可发现，两种<code>INCAR</code>的<code>NELECT</code>的参数不同。<code>NELECT</code>参数描述的是体系的电荷数，带电体系中<code>NELECT</code>数目变少，则说明此时体系带正电；反之，<code>NELECT</code>数目增多说明体系带负电。</p>
<p>该类可用于在半导体材料中由于缺陷和掺杂使得体系带电，进而研究这些带电缺陷的形成能、迁移机制等对材料的影响；也可以用于模拟电池界面上额外电荷的分布情况来研究枝晶的生长情况。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.12  计算小白硬学VASP —— 构建异质结模型</title>
    <url>/2024/08/06/Learn-VASP-from-pymatgen-12/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何自动构建异质结模型。</p>
<h3 id="CoherentInterfaceBuilder-ZSLGenerator"><a href="#CoherentInterfaceBuilder-ZSLGenerator" class="headerlink" title="CoherentInterfaceBuilder &amp; ZSLGenerator"></a>CoherentInterfaceBuilder &amp; ZSLGenerator</h3><p><code>pymatgen</code>中自动构建异质结模型需要调用<code>CoherentInterfaceBuilder</code>和<code>ZSLGenerator</code>。其中前者是用于生成<code>interfaces</code>，而后者主要是用于定义晶面的匹配度。导入方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.coherent_interfaces <span class="keyword">import</span> CoherentInterfaceBuilder</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.zsl <span class="keyword">import</span> ZSLGenerator</span><br></pre></td></tr></table></figure>

<p>首先介绍<code>ZSLGenerator</code>，原理见：<a href="https://doi.org/10.1063/1.333084">Lattice match: An application to heteroepitaxy</a>。</p>
<p><code>ZSLGenetator</code>接受四个参数传入：</p>
<ul>
<li><code>max_area_ratio_tol</code>：上下表面面积最大公差，默认为0.09；</li>
<li><code>max_area</code>：最大表面面积，默认为400$Å^2$；</li>
<li><code>max_length_tol</code>：超晶格最大公差，默认0.03；</li>
<li><code>max_angle_tol</code>：上下表面基矢角度最大公差，默认0.01；</li>
</ul>
<p><code>CoherentInterfaceBuilder</code>接受五个参数传入：</p>
<ul>
<li><code>substrate_structure</code>：基底结构；</li>
<li><code>film_structure</code>：表层结构；</li>
<li><code>film_miller</code>：表层结构米勒指数；</li>
<li><code>substrate_miller</code>：基底结构米勒指数；</li>
<li><code>zslgen</code>：<code>ZSLGenerator</code></li>
</ul>
<p>以<code>Si</code>与<code>Li</code>为例，构建异质结模型。下载对应结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;your key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    Si = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>, conventional_unit_cell=<span class="literal">True</span>)</span><br><span class="line">    Li = mpr.get_structure_by_material_id(<span class="string">&quot;mp-135&quot;</span>, conventional_unit_cell=<span class="literal">True</span>)</span><br><span class="line">    Si.to(filename=<span class="string">&quot;./Si_convention.cif&quot;</span>)</span><br><span class="line">    Li.to(filename=<span class="string">&quot;./Li_convention.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>生成<code>Si(100)/Li(100)</code>异质结：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.coherent_interfaces <span class="keyword">import</span> CoherentInterfaceBuilder</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.zsl <span class="keyword">import</span> ZSLGenerator</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构</span></span><br><span class="line">substratrate_Si = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line">film_Li = Structure.from_file(<span class="string">&quot;./Li_convention.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">cib = CoherentInterfaceBuilder(</span><br><span class="line">    substrate_structure=substratrate_Si,</span><br><span class="line">    film_structure=film_Li,</span><br><span class="line">    film_miller=([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]),</span><br><span class="line">    substrate_miller=([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]),</span><br><span class="line">    zslgen=ZSLGenerator(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成表面</span></span><br><span class="line">interfaces = cib.get_interfaces(</span><br><span class="line">    termination=cib.terminations[<span class="number">0</span>], 	<span class="comment"># 上下层结构暴露面</span></span><br><span class="line">    gap=<span class="number">2.0</span>, 							<span class="comment"># 异质结间距</span></span><br><span class="line">    vacuum_over_film=<span class="number">20.0</span>, 				<span class="comment"># 真空层厚度</span></span><br><span class="line">    film_thickness=<span class="number">2</span>, 					<span class="comment"># 表层结构厚度</span></span><br><span class="line">    substrate_thickness=<span class="number">4</span>, 				<span class="comment"># 基底结构厚度</span></span><br><span class="line">    in_layers=<span class="literal">True</span>						</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里在实例化<code>CoherentInterfaceBuilder</code>之后调用<code>get_interfaces()</code>生成所有符合条件的异质结结构。<code>get_interfaces()</code>接受六个传入参数：</p>
<ul>
<li><p><code>termination</code>：上下表面的端面。注意该参数有固定写法，可以调用<code>cib.terminations</code>查看<code>Si(100)/Li(100)</code>端面种类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(cib.terminations)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行代码输出端面的列表<code>[(&#39;Li_P4/mmm_1&#39;, &#39;Si_P4/mmm_1&#39;)]</code></p>
</blockquote>
<p><strong>Note</strong>：<code>get_interfaces()</code>中<code>termination</code>支持的数据格式为元组，所以这里用<code>cib.terminations[0]</code>来进行调用，或者直接写<code>termination=(&#39;Li_P4/mmm_1&#39;, &#39;Si_P4/mmm_1&#39;)</code>。</p>
</li>
<li><p><code>gap</code>：异质结上下表面间距；</p>
</li>
<li><p><code>vacuum_over_film</code>：真空层厚度，这里指上下表面之间的真空层；</p>
</li>
<li><p><code>film_thickness</code>&amp;<code>substrate_thickness</code>：上下<code>slab</code>厚度；</p>
</li>
<li><p><code>in_layers</code>：<code>slab</code>厚度用晶面厚度为单位，默认为<code>True</code></p>
</li>
</ul>
<p>继续，得到所有的结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.coherent_interfaces <span class="keyword">import</span> CoherentInterfaceBuilder</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.interfaces.zsl <span class="keyword">import</span> ZSLGenerator</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构</span></span><br><span class="line">substratrate_Si = Structure.from_file(<span class="string">&quot;./Si_conventional.cif&quot;</span>)</span><br><span class="line">film_Li = Structure.from_file(<span class="string">&quot;./Li_convention.cif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">cib = CoherentInterfaceBuilder(</span><br><span class="line">    substrate_structure=substratrate_Si,</span><br><span class="line">    film_structure=film_Li,</span><br><span class="line">    film_miller=([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]),</span><br><span class="line">    substrate_miller=([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]),</span><br><span class="line">    zslgen=ZSLGenerator(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成表面</span></span><br><span class="line">interfaces = cib.get_interfaces(</span><br><span class="line">    termination=cib.terminations[<span class="number">0</span>], 	<span class="comment"># 上下层结构暴露面</span></span><br><span class="line">    gap=<span class="number">2.0</span>, 							<span class="comment"># 异质结间距</span></span><br><span class="line">    vacuum_over_film=<span class="number">20.0</span>, 				<span class="comment"># 真空层厚度</span></span><br><span class="line">    film_thickness=<span class="number">2</span>, 					<span class="comment"># 表层结构厚度</span></span><br><span class="line">    substrate_thickness=<span class="number">4</span>, 				<span class="comment"># 基底结构厚度</span></span><br><span class="line">    in_layers=<span class="literal">True</span>						</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, interface <span class="keyword">in</span> <span class="built_in">enumerate</span>(interfaces):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Interface <span class="subst">&#123;i&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(interface)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total number of interfaces: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Interface 0:</span><br><span class="line">Full Formula (Li10 Si16)</span><br><span class="line">Reduced Formula: Li5Si8</span><br><span class="line">abc   :   7.698558   7.698558  27.802433</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (26)</span><br><span class="line">  #  SP       a     b         c    bulk_equivalent  bulk_wyckoff    interface_label</span><br><span class="line">---  ----  ----  ----  --------  -----------------  --------------  -----------------</span><br><span class="line">  0  Li    0     0     0.577558                  0  a               film</span><br><span class="line">  1  Li    0.4   0.2   0.577558                  0  a               film</span><br><span class="line">  2  Li    0.2   0.6   0.577558                  0  a               film</span><br><span class="line">  3  Li    0.8   0.4   0.577558                  0  a               film</span><br><span class="line">  4  Li    0.6   0.8   0.577558                  0  a               film</span><br><span class="line">  5  Li    0.1   0.3   0.639411                  0  a               film</span><br><span class="line">  6  Li    0.5   0.5   0.639411                  0  a               film</span><br><span class="line">  7  Li    0.3   0.9   0.639411                  0  a               film</span><br><span class="line">  8  Li    0.9   0.7   0.639411                  0  a               film</span><br><span class="line">  9  Li    0.7   0.1   0.639411                  0  a               film</span><br><span class="line"> 10  Si    0     0.25  0.407722                  0  a               substrate</span><br><span class="line"> 11  Si    0     0.75  0.407722                  0  a               substrate</span><br><span class="line"> 12  Si    0.5   0.25  0.407722                  0  a               substrate</span><br><span class="line"> 13  Si    0.5   0.75  0.407722                  0  a               substrate</span><br><span class="line"> 14  Si    0     0.5   0.358772                  0  a               substrate</span><br><span class="line"> 15  Si    0     0     0.358772                  0  a               substrate</span><br><span class="line"> 16  Si    0.5   0.5   0.358772                  0  a               substrate</span><br><span class="line"> 17  Si    0.5   0     0.358772                  0  a               substrate</span><br><span class="line"> 18  Si    0.25  0.5   0.505622                  0  a               substrate</span><br><span class="line"> 19  Si    0.25  0     0.505622                  0  a               substrate</span><br><span class="line"> 20  Si    0.75  0.5   0.505622                  0  a               substrate</span><br><span class="line"> 21  Si    0.75  1     0.505622                  0  a               substrate</span><br><span class="line"> 22  Si    0.25  0.25  0.456672                  0  a               substrate</span><br><span class="line"> 23  Si    0.25  0.75  0.456672                  0  a               substrate</span><br><span class="line"> 24  Si    0.75  0.25  0.456672                  0  a               substrate</span><br><span class="line"> 25  Si    0.75  0.75  0.456672                  0  a               substrate</span><br><span class="line"> ......</span><br><span class="line"> ......</span><br><span class="line"> Total number of interfaces: 191</span><br></pre></td></tr></table></figure>

<p>符合要求的<code>interfaces</code>总共有191个。<code>interfaces</code>的类型是一个迭代器，不能直接调用输出其中的结果，但是可以先转化成<code>list</code>，然后可以导出第一个结构看下结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># 转化成列表</span></span><br><span class="line">Interfaces = <span class="built_in">list</span>(interfaces)</span><br><span class="line"><span class="comment"># 输出第一个结构</span></span><br><span class="line">Interfaces[<span class="number">0</span>].to(<span class="string">&quot;./Heter_1.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>VESTA</code>打开：</p>
<p><img src="/2024/08/06/Learn-VASP-from-pymatgen-12/image-20240806094616702.png" alt="image-20240806094616702"></p>
<p>可以再输出最后一个结构对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># 转化成列表</span></span><br><span class="line">Interfaces = <span class="built_in">list</span>(interfaces)</span><br><span class="line"><span class="comment"># 输出最后一个结构</span></span><br><span class="line">Interfaces[<span class="number">190</span>].to(<span class="string">&quot;./Heter_191.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>VESTA</code>打开：</p>
<p><img src="/2024/08/06/Learn-VASP-from-pymatgen-12/image-20240806094820632.png" alt="image-20240806094820632"></p>
<p>可以发现同样的情况下，最后一个结构整体结构要大很多，相对更复杂。</p>
<p>这是因为<code>Interfaces</code>里储存的结构是根据结构从简单到复杂进行排列，这里的”复杂”对应的是程序为了搜索匹配的超晶格表面，会自动进行晶格重定向或晶格基矢转变来进行匹配。</p>
<p>实际使用时，为了节省计算时间，推荐选取最靠前的几个结构进行计算即可。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.15  计算小白硬学VASP —— 各类结构“Transformation”使用说明（二）</title>
    <url>/2024/08/16/Learn-VASP-from-pymatgen-15/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>继续介绍<code>pymatgen</code>中<code>standard_transformations</code>中各类<code>Transformation</code>的使用说明。</p>
<h3 id="SubstitutionTransformation"><a href="#SubstitutionTransformation" class="headerlink" title="SubstitutionTransformation"></a>SubstitutionTransformation</h3><p><code>SubstitutionTransformation</code>类主要用于对结构进行某一元素替换或者部分掺杂。如何控制替换的元素活掺杂比例？则需要我们在使用时传入<code>species_map</code>参数，以<code>Si</code>为例：</p>
<ul>
<li>完全替换元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> SubstitutionTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始结构</span></span><br><span class="line">ini_Si = Cifparser(<span class="string">&#x27;./Si.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;初始结构：\n<span class="subst">&#123;ini_si&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换规则，Si全部替换为C</span></span><br><span class="line">species_map = &#123;<span class="string">&#x27;Si&#x27;</span>:<span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line">sub_trans =  SubstitutionTransformation(species_map)</span><br><span class="line">new_C = sub_trans.apply_transformation(ini_Si)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;全部替换为C：\n<span class="subst">&#123;new_C&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">初始结构：</span><br><span class="line">Full Formula (Si8)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  <span class="params">#</span>  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  Si    0     0     0</span><br><span class="line">  1  Si    0.25  0.25  0.25</span><br><span class="line">  2  Si    0     0.5   0.5</span><br><span class="line">  3  Si    0.75  0.25  0.75</span><br><span class="line">  4  Si    0.25  0.75  0.75</span><br><span class="line">  5  Si    0.75  0.75  0.25</span><br><span class="line">  6  Si    0.5   0     0.5</span><br><span class="line">  7  Si    0.5   0.5   0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">全部替换为C：</span><br><span class="line">Full Formula (C8)</span><br><span class="line">Reduced Formula: C</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  <span class="params">#</span>  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  C     0     0     0</span><br><span class="line">  1  C     0.25  0.25  0.25</span><br><span class="line">  2  C     0     0.5   0.5</span><br><span class="line">  3  C     0.75  0.25  0.75</span><br><span class="line">  4  C     0.25  0.75  0.75</span><br><span class="line">  5  C     0.75  0.75  0.25</span><br><span class="line">  6  C     0.5   0     0.5</span><br><span class="line">  7  C     0.5   0.5   0</span><br></pre></td></tr></table></figure>

<ul>
<li>部分掺杂</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> SubstitutionTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始结构</span></span><br><span class="line">ini_Si = Cifparser(<span class="string">&#x27;./Si.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;初始结构：\n<span class="subst">&#123;ini_si&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Si位点掺杂50%C</span></span><br><span class="line">species_map = &#123;<span class="string">&#x27;Si&#x27;</span>:&#123;<span class="string">&#x27;Si&#x27;</span>:<span class="number">0.9</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">0.1</span>&#125;&#125;</span><br><span class="line">sub_trans =  SubstitutionTransformation(species_map)</span><br><span class="line">new_Si = sub_trans.apply_transformation(ini_Si)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;掺杂50%C：\n<span class="subst">&#123;new_Si&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">初始结构：</span><br><span class="line">Full Formula (Si8)</span><br><span class="line">Reduced Formula: Si</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  <span class="params">#</span>  SP       a     b     c</span><br><span class="line">---  ----  ----  ----  ----</span><br><span class="line">  0  Si    0     0     0</span><br><span class="line">  1  Si    0.25  0.25  0.25</span><br><span class="line">  2  Si    0     0.5   0.5</span><br><span class="line">  3  Si    0.75  0.25  0.75</span><br><span class="line">  4  Si    0.25  0.75  0.75</span><br><span class="line">  5  Si    0.75  0.75  0.25</span><br><span class="line">  6  Si    0.5   0     0.5</span><br><span class="line">  7  Si    0.5   0.5   0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">掺杂50<span class="comment">%C：</span></span><br><span class="line">Full Formula (Si4 C4)</span><br><span class="line">Reduced Formula: SiC</span><br><span class="line">abc   :   5.443702   5.443702   5.443702</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (8)</span><br><span class="line">  <span class="params">#</span>  SP                a     b     c</span><br><span class="line">---  -------------  ----  ----  ----</span><br><span class="line">  0  Si:0.5, C:0.5  0     0     0</span><br><span class="line">  1  Si:0.5, C:0.5  0.25  0.25  0.25</span><br><span class="line">  2  Si:0.5, C:0.5  0     0.5   0.5</span><br><span class="line">  3  Si:0.5, C:0.5  0.75  0.25  0.75</span><br><span class="line">  4  Si:0.5, C:0.5  0.25  0.75  0.75</span><br><span class="line">  5  Si:0.5, C:0.5  0.75  0.75  0.25</span><br><span class="line">  6  Si:0.5, C:0.5  0.5   0     0.5</span><br><span class="line">  7  Si:0.5, C:0.5  0.5   0.5   0</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>：<code>SubstitutionTransformation</code>替换只区别元素符号，不区分位点。如果没有特殊的区分，<code>SubstitutionTransformation</code>考虑的体系中所有的同类原子。</p>
<p>如果只需要替换指定<code>wyckoff site</code>位点的元素，能实现吗？</p>
<p>以<code>LiFePO4</code>为例，首先需要保证<code>LiFePO4</code>具有完整的对称性，这样才会识别出不同的位点，如果<code>cif</code>结构不包含对称的性，打印出的结构信息只是所有原子的坐标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line">ini_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;初始结构：\n<span class="subst">&#123;ini_LFP&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">初始结构：</span><br><span class="line">Full Formula (Li4 Fe4 P4 O16)</span><br><span class="line">Reduced Formula: LiFePO4</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP           a         b         c</span><br><span class="line">---  ----  --------  --------  --------</span><br><span class="line">  0  Li+   0         0         0</span><br><span class="line">  1  Li+   0.5       0         0.5</span><br><span class="line">  2  Li+   0.5       0.5       0.5</span><br><span class="line">  3  Li+   0         0.5       0</span><br><span class="line">  4  Fe2+  0.218849  0.25      0.529866</span><br><span class="line">  5  Fe2+  0.781151  0.75      0.470134</span><br><span class="line">  6  Fe2+  0.281151  0.75      0.029866</span><br><span class="line">  7  Fe2+  0.718849  0.25      0.970134</span><br><span class="line">  8  P5+   0.093866  0.75      0.581377</span><br><span class="line">  9  P5+   0.906134  0.25      0.418623</span><br><span class="line"> 10  P5+   0.406134  0.25      0.081377</span><br><span class="line"> 11  P5+   0.593866  0.75      0.918623</span><br><span class="line"> 12  O2-   0.165845  0.545558  0.713735</span><br><span class="line"> 13  O2-   0.834155  0.454442  0.286265</span><br><span class="line"> 14  O2-   0.334155  0.454442  0.213735</span><br><span class="line"> 15  O2-   0.665845  0.545558  0.786265</span><br><span class="line"> 16  O2-   0.665845  0.954442  0.786265</span><br><span class="line"> 17  O2-   0.334155  0.045558  0.213735</span><br><span class="line"> 18  O2-   0.834155  0.045558  0.286265</span><br><span class="line"> 19  O2-   0.165845  0.954442  0.713735</span><br><span class="line"> 20  O2-   0.044309  0.25      0.290136</span><br><span class="line"> 21  O2-   0.955691  0.75      0.709864</span><br><span class="line"> 22  O2-   0.455691  0.75      0.790136</span><br><span class="line"> 23  O2-   0.544309  0.25      0.209864</span><br><span class="line"> 24  O2-   0.094231  0.75      0.255213</span><br><span class="line"> 25  O2-   0.905769  0.25      0.744787</span><br><span class="line"> 26  O2-   0.405769  0.25      0.755213</span><br><span class="line"> 27  O2-   0.594231  0.75      0.244787</span><br></pre></td></tr></table></figure>

<p>这样是不利于进行掺杂操作的。虽然在<code>parse_structures()[0]</code>中可以添加<code>symmetrized=True</code>来寻找对称性，但是如果初始<code>cif</code>文件中信息不全，是没办法得到正确的结果的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line">rough_symm_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures(symmetrized=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;粗略对称性：\n<span class="subst">&#123;rough_symm_LFP&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">粗略对称性：</span><br><span class="line">SymmetrizedStructure</span><br><span class="line">Full Formula (Li4 Fe4 P4 O16)</span><br><span class="line">Reduced Formula: LiFePO4</span><br><span class="line">Spacegroup: Not Parsed (-1)</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP           a         b         c  Wyckoff</span><br><span class="line">---  ----  --------  --------  --------  ------------</span><br><span class="line">  0  O2-   0.165845  0.545558  0.713735  16Not Parsed</span><br><span class="line">  1  P5+   0.093866  0.75      0.581377  4Not Parsed</span><br><span class="line">  2  Fe2+  0.218849  0.25      0.529866  4Not Parsed</span><br><span class="line">  3  Li+   0         0         0         4Not Parsed</span><br></pre></td></tr></table></figure>

<p>该方法无法正确识别<code>Wyckoff Site</code>，可能原因就是<code>cif</code>结构中不包含空间群等信息，所以最保险的办法是调用<code>SpacegroupAnalyzer</code>来得到包含对称性的结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line">ini_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line">symm_LFP = SpacegroupAnalyzer(ini_LFP).get_symmetrized_structure()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;添加对称性后：\n<span class="subst">&#123;symm_LFP&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">添加对称性后：</span><br><span class="line">SymmetrizedStructure</span><br><span class="line">Full Formula (Li4 Fe4 P4 O16)</span><br><span class="line">Reduced Formula: LiFePO4</span><br><span class="line">Spacegroup: Pnma (62)</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP           a         b         c  Wyckoff</span><br><span class="line">---  ----  --------  --------  --------  ---------</span><br><span class="line">  0  Li+   0         0         0         4a</span><br><span class="line">  1  Fe2+  0.218849  0.25      0.529866  4c</span><br><span class="line">  2  P5+   0.093866  0.75      0.581377  4c</span><br><span class="line">  3  O2-   0.165845  0.545558  0.713735  8d</span><br><span class="line">  4  O2-   0.044309  0.25      0.290136  4c</span><br><span class="line">  5  O2-   0.094231  0.75      0.255213  4c</span><br></pre></td></tr></table></figure>

<p>此时可正确显示<code>O</code>元素有三种位点，两个<code>4c</code>位，一个<code>8d</code>位。</p>
<p>在此基础上，如果我们仅考虑在<code>8d</code>位<code>O</code>位掺杂<code>S</code>，能不能实现呢？？</p>
<p><code>pymatgen</code>目前版本中没有能够直接针对<code>Wyckoff Site</code>来进行<code>Partial Substitutions</code>的类，所以下面是我想出的一个解决办法：</p>
<ul>
<li><strong>找到所有<code>8d</code>位的<code>O</code>原子的<code>indices</code></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"></span><br><span class="line">ini_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取结构中所有的wyckoff sites</span></span><br><span class="line">wyckoff_sites = SpacegroupAnalyzer(ini_LFP).get_symmetry_dataset().wyckoffs</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line"><span class="built_in">print</span>(wyckoff_sites)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">wyckoff<span class="built_in">_</span>sites: [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>：这里打印出的只有<code>wyckoff site</code>名称中的字母部分，并没有数字部分，即没有显示对称位置的数量，但是不妨碍我们去获取<code>8d</code>的<code>indices</code></p>
<ul>
<li><strong>获取<code>8d</code>位<code>O</code>的所有<code>indices</code></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">oxygen_d_indices = [i <span class="keyword">for</span> i, site <span class="keyword">in</span> <span class="built_in">enumerate</span>(wyckoff_sites) <span class="keyword">if</span> site == <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;oxygen_d_indices: <span class="subst">&#123;oxygen_d_indices&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oxygen<span class="built_in">_</span>d<span class="built_in">_</span>indices: [12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure>

<p>这里<code>d</code>的<code>wyckoff site</code>是唯一的，所以我们只需要对上一步打印的结果进行统计即可，但是如果我们想要对<code>4c</code>位的<code>O</code>进行掺杂，这里就需要增加限定条件了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># 4c O位掺杂</span></span><br><span class="line">oxygen_c_indices = [i <span class="keyword">for</span> i, site <span class="keyword">in</span> <span class="built_in">enumerate</span>(wyckoff_sites) <span class="keyword">if</span> site == <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> ini_LFP.sites[i].specie.symbol == <span class="string">&#x27;O&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;oxygen_c_indices: <span class="subst">&#123;oxygen_c_indices&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oxygen<span class="built_in">_</span>c<span class="built_in">_</span>indices: [20, 21, 22, 23, 24, 25, 26, 27]</span><br></pre></td></tr></table></figure>

<p>同理，如果相对<code>4c</code>位的<code>Fe</code>或<code>P</code>掺杂，只需要修改对应限制条件为<code>ini_LFP.sites[i].specie.symbol == &#39;target_element&#39;</code>即可。</p>
<p>回到正题，筛选出了<code>indices</code>，然后进行部分掺杂替换：</p>
<ul>
<li><strong>替换位点</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.site_transformations <span class="keyword">import</span> ReplaceSiteSpeciesTransformation</span><br><span class="line"></span><br><span class="line">final_LFP = ini_LFP.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> oxygen_d_indices:</span><br><span class="line">    indices_species_map = &#123;i:&#123;<span class="string">&#x27;O2-&#x27;</span>:<span class="number">0.9</span>, <span class="string">&#x27;S2-&#x27;</span>:<span class="number">0.1</span>&#125;&#125;</span><br><span class="line">    trans = ReplaceSiteSpeciesTransformation(indices_species_map)</span><br><span class="line">    final_LFP = trans.apply_transformation(final_LFP)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最终结构：\n<span class="subst">&#123;final_LFP&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们需要导入另外一个类的方法<code>ReplaceSiteSpeciesTransformation</code>，然后用一个循环对每一个目标位点进行替换，最终结构为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">最终结构：</span><br><span class="line">Full Formula (Li4 Fe4 P4 S0.8 O15.2)</span><br><span class="line">Reduced Formula: Li4Fe4P4S0.8O15.2</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP                       a         b         c</span><br><span class="line">---  ----------------  --------  --------  --------</span><br><span class="line">  0  Li+               0         0         0</span><br><span class="line">  1  Li+               0.5       0         0.5</span><br><span class="line">  2  Li+               0.5       0.5       0.5</span><br><span class="line">  3  Li+               0         0.5       0</span><br><span class="line">  4  Fe2+              0.218849  0.25      0.529866</span><br><span class="line">  5  Fe2+              0.781151  0.75      0.470134</span><br><span class="line">  6  Fe2+              0.281151  0.75      0.029866</span><br><span class="line">  7  Fe2+              0.718849  0.25      0.970134</span><br><span class="line">  8  P5+               0.093866  0.75      0.581377</span><br><span class="line">  9  P5+               0.906134  0.25      0.418623</span><br><span class="line"> 10  P5+               0.406134  0.25      0.081377</span><br><span class="line"> 11  P5+               0.593866  0.75      0.918623</span><br><span class="line"> 12  S2-:0.1, O2-:0.9  0.165845  0.545558  0.713735</span><br><span class="line"> 13  S2-:0.1, O2-:0.9  0.834155  0.454442  0.286265</span><br><span class="line"> 14  S2-:0.1, O2-:0.9  0.334155  0.454442  0.213735</span><br><span class="line"> 15  S2-:0.1, O2-:0.9  0.665845  0.545558  0.786265</span><br><span class="line"> 16  S2-:0.1, O2-:0.9  0.665845  0.954442  0.786265</span><br><span class="line"> 17  S2-:0.1, O2-:0.9  0.334155  0.045558  0.213735</span><br><span class="line"> 18  S2-:0.1, O2-:0.9  0.834155  0.045558  0.286265</span><br><span class="line"> 19  S2-:0.1, O2-:0.9  0.165845  0.954442  0.713735</span><br><span class="line"> 20  O2-               0.044309  0.25      0.290136</span><br><span class="line"> 21  O2-               0.955691  0.75      0.709864</span><br><span class="line"> 22  O2-               0.455691  0.75      0.790136</span><br><span class="line"> 23  O2-               0.544309  0.25      0.209864</span><br><span class="line"> 24  O2-               0.094231  0.75      0.255213</span><br><span class="line"> 25  O2-               0.905769  0.25      0.744787</span><br><span class="line"> 26  O2-               0.405769  0.25      0.755213</span><br><span class="line"> 27  O2-               0.594231  0.75      0.244787</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了只对特定的<code>wyckoff site</code>进行替换操作。</p>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的pymatgen模块</span></span><br><span class="line"><span class="keyword">from</span> pymatgen.transformations.site_transformations <span class="keyword">import</span> ReplaceSiteSpeciesTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从CIF文件中解析初始LiFePO4结构</span></span><br><span class="line">ini_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line">rough_symm_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures(symmetrized=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取初始结构的对称化信息</span></span><br><span class="line">symm_LFP = SpacegroupAnalyzer(ini_LFP).get_symmetrized_structure()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;初始结构：\n<span class="subst">&#123;ini_LFP&#125;</span>\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;粗略对称性：\n<span class="subst">&#123;rough_symm_LFP&#125;</span>\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;添加对称性后：\n<span class="subst">&#123;symm_LFP&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取wyckoff位点信息</span></span><br><span class="line">wyckoff_sites = SpacegroupAnalyzer(ini_LFP).get_symmetry_dataset().wyckoffs</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;wyckoff_sites: <span class="subst">&#123;wyckoff_sites&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取4d位O原子索引</span></span><br><span class="line">oxygen_d_indices = [i <span class="keyword">for</span> i, site <span class="keyword">in</span> <span class="built_in">enumerate</span>(wyckoff_sites) <span class="keyword">if</span> site == <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;oxygen_d_indices: <span class="subst">&#123;oxygen_d_indices&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行替换</span></span><br><span class="line">final_LFP = ini_LFP.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> oxygen_d_indices:</span><br><span class="line">    indices_species_map = &#123;i:&#123;<span class="string">&#x27;O2-&#x27;</span>:<span class="number">0.9</span>, <span class="string">&#x27;S2-&#x27;</span>:<span class="number">0.1</span>&#125;&#125;</span><br><span class="line">    trans = ReplaceSiteSpeciesTransformation(indices_species_map)</span><br><span class="line">    final_LFP = trans.apply_transformation(final_LFP)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最终结构：\n<span class="subst">&#123;final_LFP&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当然，这里我们是直接用代码来给结构增加<code>partial substitution</code>信息；当然你也可以直接在<code>cif</code>结构里直接修改<code>occupation</code>占据也是可以的。</p>
<p>本章花这么大篇幅介绍<code>partial substitution</code>，是为了解决材料研究中掺杂结构的建模问题。第一步是构建出符合预期，符合实验条件的<code>partial substitution</code>的结构，这里也叫做分数占据结构；下一步就是如何确切的构建出不含分数占据的结构，即<code>ordered structure</code>，可以直接用于<code>VASP</code>直接计算。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.16  计算小白硬学VASP —— 各类结构“Transformation”使用说明（三）</title>
    <url>/2024/08/19/Learn-VASP-from-pymatgen-16/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>上一章介绍了怎么构建<code>disordered</code>分数占据结构，本章介绍怎么从<code>disordered</code>分数占据结构中生成可以直接计算的结构。</p>
<h3 id="OrderDisorderedStructureTransformation"><a href="#OrderDisorderedStructureTransformation" class="headerlink" title="OrderDisorderedStructureTransformation"></a>OrderDisorderedStructureTransformation</h3><p>上一章以<code>LiFePO4</code>为例，在<code>8a</code>O位点替换掺杂S元素，生成的<code>disordered</code>结构如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Full Formula (Li4 Fe4 P4 S0.8 O15.2)</span><br><span class="line">Reduced Formula: Li4Fe4P4S0.8O15.2</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">pbc   :       True       True       True</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP                       a         b         c</span><br><span class="line">---  ----------------  --------  --------  --------</span><br><span class="line">  0  Li+               0         0         0</span><br><span class="line">  1  Li+               0.5       0         0.5</span><br><span class="line">  2  Li+               0.5       0.5       0.5</span><br><span class="line">  3  Li+               0         0.5       0</span><br><span class="line">  4  Fe2+              0.218849  0.25      0.529866</span><br><span class="line">  5  Fe2+              0.781151  0.75      0.470134</span><br><span class="line">  6  Fe2+              0.281151  0.75      0.029866</span><br><span class="line">  7  Fe2+              0.718849  0.25      0.970134</span><br><span class="line">  8  P5+               0.093866  0.75      0.581377</span><br><span class="line">  9  P5+               0.906134  0.25      0.418623</span><br><span class="line"> 10  P5+               0.406134  0.25      0.081377</span><br><span class="line"> 11  P5+               0.593866  0.75      0.918623</span><br><span class="line"> 12  S2-:0.1, O2-:0.9  0.165845  0.545558  0.713735</span><br><span class="line"> 13  S2-:0.1, O2-:0.9  0.834155  0.454442  0.286265</span><br><span class="line"> 14  S2-:0.1, O2-:0.9  0.334155  0.454442  0.213735</span><br><span class="line"> 15  S2-:0.1, O2-:0.9  0.665845  0.545558  0.786265</span><br><span class="line"> 16  S2-:0.1, O2-:0.9  0.665845  0.954442  0.786265</span><br><span class="line"> 17  S2-:0.1, O2-:0.9  0.334155  0.045558  0.213735</span><br><span class="line"> 18  S2-:0.1, O2-:0.9  0.834155  0.045558  0.286265</span><br><span class="line"> 19  S2-:0.1, O2-:0.9  0.165845  0.954442  0.713735</span><br><span class="line"> 20  O2-               0.044309  0.25      0.290136</span><br><span class="line"> 21  O2-               0.955691  0.75      0.709864</span><br><span class="line"> 22  O2-               0.455691  0.75      0.790136</span><br><span class="line"> 23  O2-               0.544309  0.25      0.209864</span><br><span class="line"> 24  O2-               0.094231  0.75      0.255213</span><br><span class="line"> 25  O2-               0.905769  0.25      0.744787</span><br><span class="line"> 26  O2-               0.405769  0.25      0.755213</span><br><span class="line"> 27  O2-               0.594231  0.75      0.244787</span><br></pre></td></tr></table></figure>

<p>把上述结构提取对称性，可以更直观的看出替换信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.......</span><br><span class="line">final_LFP = SpacegroupAnalyzer(final_LFP).get_symmetrized_structure()</span><br><span class="line"><span class="built_in">print</span>(final_LFP)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">SymmetrizedStructure</span><br><span class="line">Full Formula (Li4 Fe4 P4 S0.8 O15.2)</span><br><span class="line">Reduced Formula: Li4Fe4P4S0.8O15.2</span><br><span class="line">Spacegroup: Pnma (62)</span><br><span class="line">abc   :  10.236196   5.970755   4.654917</span><br><span class="line">angles:  90.000000  90.000000  90.000000</span><br><span class="line">Sites (28)</span><br><span class="line">  <span class="params">#</span>  SP                       a         b         c  Wyckoff</span><br><span class="line">---  ----------------  --------  --------  --------  ---------</span><br><span class="line">  0  Li+               0         0         0         4a</span><br><span class="line">  1  Fe2+              0.218849  0.25      0.529866  4c</span><br><span class="line">  2  P5+               0.093866  0.75      0.581377  4c</span><br><span class="line">  3  S2-:0.1, O2-:0.9  0.165845  0.545558  0.713735  8d</span><br><span class="line">  4  O2-               0.044309  0.25      0.290136  4c</span><br><span class="line">  5  O2-               0.094231  0.75      0.255213  4c</span><br></pre></td></tr></table></figure>

<p>下一步就是如何生成<code>ordered</code>结构，现在就是要用到<code>OrderDisorderedStructureTransformation</code>类：</p>
<ul>
<li><code>algo</code>：使用的算法，可选：<code>ALGO_BEST_FIRST=2</code>、<code>ALGO_COMPLETE=1</code>、<code>ALGO_FAST=0</code>；默认为0。</li>
<li><code>symmetrized_structures</code>：输入结构是否包含对称性</li>
<li><code>no_oxo_states</code>：是否去除价态</li>
</ul>
<p>在调用前，我们需要查看下输入结构信息，如果包含对称性，即上述后者的结构信息，则需要打开<code>symmetrized_structures=True</code></p>
<p>其次，还需要判断初始结构中的<code>disordered</code>位点是否能够分配，否者则需要先超胞。通俗地讲，消除<code>disordered</code>位点的办法就是随机分配位点，如，上述<code>8a</code>O位惯用胞中总共有8个位点，但<code>O ：S</code>的占据比为<code>9 : 1</code>，如此一来则位点不够分配，则需要先超胞提供足够多的位点，然后再进行操作。</p>
<p>这里，为了方便直接跟惯用胞对比，我们改一下掺杂比例<code>O ：S</code>的占据比为<code>1 : 1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.transformations.standard_transformations <span class="keyword">import</span> OrderDisorderedStructureTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifParser</span><br><span class="line"><span class="keyword">from</span> pymatgen.transformations.site_transformations <span class="keyword">import</span> ReplaceSiteSpeciesTransformation</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.cif <span class="keyword">import</span> CifWriter</span><br><span class="line"></span><br><span class="line">ini_LFP = CifParser(<span class="string">&#x27;./LiFePO4.cif&#x27;</span>).parse_structures()[<span class="number">0</span>]</span><br><span class="line">symm_LFP = SpacegroupAnalyzer(ini_LFP).get_symmetrized_structure()</span><br><span class="line"></span><br><span class="line">wyckoff_sites = SpacegroupAnalyzer(ini_LFP).get_symmetry_dataset().wyckoffs</span><br><span class="line"></span><br><span class="line">oxygen_d_indices = [i <span class="keyword">for</span> i, site <span class="keyword">in</span> <span class="built_in">enumerate</span>(wyckoff_sites) <span class="keyword">if</span> site == <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制初始结构到最终结构</span></span><br><span class="line">final_LFP = ini_LFP.copy()</span><br><span class="line"><span class="comment"># 对类型为&#x27;d&#x27;的氧原子位点进行物种替换</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> oxygen_d_indices:</span><br><span class="line">    indices_species_map = &#123;i:&#123;<span class="string">&#x27;O2-&#x27;</span>:<span class="number">0.5</span>, <span class="string">&#x27;S2-&#x27;</span>:<span class="number">0.5</span>&#125;&#125;  <span class="comment"># 替换比例为O2-:0.5, S2-:0.5</span></span><br><span class="line">    trans = ReplaceSiteSpeciesTransformation(indices_species_map)  <span class="comment"># 创建替换物种变换对象</span></span><br><span class="line">    final_LFP = trans.apply_transformation(final_LFP)  <span class="comment"># 应用变换到最终结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先保存初始disordered结构</span></span><br><span class="line">final_LFP = SpacegroupAnalyzer(final_LFP).get_symmetrized_structure()</span><br><span class="line">CifWriter(final_LFP,symprec=<span class="number">0.01</span>).write_file(<span class="string">&#x27;./LiFePO4_doped.cif&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">trans = OrderDisorderedStructureTransformation(algo=<span class="number">0</span>,symmetrized_structures=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成结构</span></span><br><span class="line">ordered_LFPs = trans.apply_transformation(input_struct,return_ranked_list=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结构</span></span><br><span class="line"><span class="keyword">for</span> i,struct <span class="keyword">in</span> <span class="built_in">enumerate</span>(ordered_LFPs):</span><br><span class="line">    CifWriter(struct[<span class="string">&#x27;structure&#x27;</span>],symprec=<span class="number">0.01</span>).write_file(<span class="string">f&#x27;./LiFePO4_doped_<span class="subst">&#123;i&#125;</span>.cif&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>apply_transformation</code>中<code>return_ranked_list=5</code>表示输出五个目标<code>ordered</code>结构，否则只会输出一个结构。</p>
<p>把输出结构导入<code>VESTA</code>查看：</p>
<p><img src="/2024/08/19/Learn-VASP-from-pymatgen-16/image-20240819111140780.png" alt="image-20240819111140780"></p>
<p><strong>Note</strong>：该方法进行分配时不会考虑对称性来较少目标结构的总数量，所以对于生成的<code>Ordered</code>结构，需要甄别一下再提交<code>VASP</code>计算。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.2  计算小白硬学VASP —— 前期准备</title>
    <url>/2024/05/30/Learn-VASP-from-pymatgen-2/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>今天正式进入本系列内容，首先介绍下如何配置pymatgen相关环境，本章如果能全程跟下来且最后配置成功，那么恭喜你，该系列的核心内容已经完成了50%。</p>
<hr>
<p>首先你需要一台已经编译好VASP的个人工作站或者使用已经编译了VASP的超算中心；有头铁的大哥想用自己的笔记本电脑也行，也请提前准备好虚拟环境编译好VASP。</p>
<p>然后开始配置pymatgen相关环境，<a href="https://pymatgen.org/installation.html">官网</a>的安装教程已经相对详细了。但是考虑到本系列是“计算小白硬学VASP”，主打的就是我奶奶看了都会提交VASP任务，这里我就手把手，step by step 地走一遍配置过程。</p>
<mark class="hl-label default">后续操作均在Linux环境下进行，个人工作站请在工作站上面操作，超算中心请在账号家目录下进行。blue</mark>

<h2 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h2><p>Miniconda是一个开源的Python发行版本，它包含了conda、Python、pip等包管理工具，并且可以轻松安装、卸载、管理不同版本的Python环境。与Anaconda相比，Miniconda体量更小，安装速度更快，适合于个人用户、小型团队或学习目的（<em>官网教程也推荐Miniconda，我信Prof.Ceder</em>）。</p>
<h3 id="官网下载Miniconda安装包"><a href="#官网下载Miniconda安装包" class="headerlink" title="官网下载Miniconda安装包"></a><a href="https://docs.anaconda.com/free/miniconda/">官网</a>下载Miniconda安装包</h3><p><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/1_linux_pkg.png" alt="Linux_version 安装包"></p>
<h3 id="进入到安装包目录下bash命令安装"><a href="#进入到安装包目录下bash命令安装" class="headerlink" title="进入到安装包目录下bash命令安装"></a>进入到安装包目录下bash命令安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<h3 id="验证Miniconda是否安装成功"><a href="#验证Miniconda是否安装成功" class="headerlink" title="验证Miniconda是否安装成功"></a>验证Miniconda是否安装成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda --version # 或conda -V</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果安装成功，会显示conda的版本号。<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/2_check_miniconda_installation.png" alt="Linux_version conda版本"></p>
<h2 id="配置pymatgen环境"><a href="#配置pymatgen环境" class="headerlink" title="配置pymatgen环境"></a>配置pymatgen环境</h2><h3 id="为pymatgen创建独立的运行环境"><a href="#为pymatgen创建独立的运行环境" class="headerlink" title="为pymatgen创建独立的运行环境"></a>为pymatgen创建独立的运行环境</h3><p>为什么要创建独立的运行环境？</p>
<ul>
<li>首先，不同package的对python以及其他依赖的版本有要求，为了避免跟base的环境相冲突，最简单的做法就是新建一个环境；</li>
<li>其次，对于超算用户，尤其是多人共用一个账号，配置新的环境避免与其他用户的使用需求相冲突，同时也有效的保护自己配置的环境不受影响。<br>操作如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create --name my_pymatgen python</span><br></pre></td></tr></table></figure>
此时可以查看当前conda环境列表：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
出现下述环境列表，说明<code>my_pymatgen</code>环境新建成功，<code>*</code>号表示当前所使用的conda环境。<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/3_conda_env_list.png" alt="Linux_version conda环境列表"><br>我们需要激活<code>my_pymatgen</code>环境来配置<code>pymatgen</code>，同时以后每次使用pymatgen都要记住激活<code>my_pymatgen</code>环境。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate my_pymatgen</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<p>此时可以看见已经激活my_pymatgen环境，<code>*</code>号变成了<code>my_pymatgen</code>。<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/4_activate_my_pymatgen.png" alt="Linux_version conda环境列表"></p>
<h3 id="安装pymatgen"><a href="#安装pymatgen" class="headerlink" title="安装pymatgen"></a>安装pymatgen</h3><p>直接通过conda命令安装pymatgen：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge pymatgen</span><br></pre></td></tr></table></figure>

<h3 id="验证pymatgen安装成功"><a href="#验证pymatgen安装成功" class="headerlink" title="验证pymatgen安装成功"></a>验证pymatgen安装成功</h3><p>命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda list pymatgen</span><br></pre></td></tr></table></figure>
<p>出现下述输出，说明pymatgen安装成功。<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/5_check_pymatgen_installation.png" alt="Linux_version pymatgen安装成功"></p>
<p><strong>别着急，还没完！！！距离完成只差最后一步了~~~~~~~</strong></p>
<h3 id="配置pymatgen势函数"><a href="#配置pymatgen势函数" class="headerlink" title="配置pymatgen势函数"></a>配置pymatgen势函数</h3><p>最后我们需要配置一下势函数文件，首先你需要准备好VASP的势函数文件，由于版权问题，自行解决。一般势函数文件格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POT_PAW_PBE</span><br><span class="line">├── Ac</span><br><span class="line">│   ├── POTCAR</span><br><span class="line">│   └── PSCTR</span><br><span class="line">├── Ag</span><br><span class="line">│   ├── POTCAR</span><br><span class="line">│   └── PSCTR</span><br></pre></td></tr></table></figure>
<p>上述初始势函数的路径记作<code>&lt;EXTRACTED_VASP_POTCAR&gt;</code>，然后再命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmg config -p &lt;EXTRACTED_VASP_POTCAR&gt; &lt;MY_PSP&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;MY_PSP&gt;</code>是你自定义配置<code>pymatgen</code>可以识别的势函数的路径，比如<code>my_psp</code>，然后会指定路径下生成一个<code>my_psp</code>文件夹，里面文件格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;MY_PSP&gt;</span><br><span class="line">├── POT_GGA_PAW_PBE</span><br><span class="line">│   ├── POTCAR.Ac.gz</span><br><span class="line">│   ├── POTCAR.Ag.gz</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>最后，需要把<code>&lt;MY_PSP&gt;</code>配置的pyamtgen环境变量中，这样才能在使用<code>pymatgen</code>时识别到自定义的势函数，命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmg config --add PMG_VASP_PSP_DIR &lt;MY_PSP&gt;</span><br></pre></td></tr></table></figure>
<p>验证是否配置成功，可在根目录<code>.config/.pmgrc.yaml</code>文件中查看<code>PMG_VASP_PSP_DIR</code>配置项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.config/.pmgrc.yaml</span><br></pre></td></tr></table></figure>
<p>出现如下信息，说明配置成功。<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-2/6_check_pmg_potential.png" alt="Linux_version pymatgen配置成功"></p>
<div class="note info flat"><p>VASP有许多不同的势函数，比如<code>PBE</code>，<code>LDA</code>等等，这里我们只配置了<code>PBE</code>的势函数，如果你需要其他势函数，请自行配置。配置方法与上述相同，只需替换<code>&lt;EXTRACTED_VASP_POTCAR&gt;</code>和<code>&lt;MY_PSP&gt;</code>即可。</p>
</div>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmg config -p /path/to/pseudos/potcar_PBE.54 /path/to/pseudos/pmg_potcars</span><br><span class="line">pmg config -p /path/to/pseudos/potcar_LDA.54 /path/to/pseudos/pmg_potcars</span><br><span class="line">pmg config --add PMG_VASP_PSP_DIR /path/to/pseudos/pmg_potcars</span><br></pre></td></tr></table></figure>
<p>使用时注意指定势函数种类（后面会讲），或者直接把常用的势函数设置成默认选项，当然如果只添加了一种势函数，该步骤可以省略。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmg config --add PMG_DEFAULT_FUNCTIONAL PBE_52</span><br></pre></td></tr></table></figure>

<hr>
<p>自此，前期准备工作基本已经完成，接下来就是正式进入实操阶段了，敬请期待！</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.3  计算小白硬学VASP —— 学会使用Materials Project</title>
    <url>/2024/05/30/Learn-VASP-from-pymatgen-3/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>很遗憾的告诉各位，本章还没有开始涉及到VASP的计算。</p>
<p><strong>Why????</strong></p>
<p>根据老司机以往的使用经验，做计算最关键的不是了解各种输入参数的意义，不是高超的编程能力，不是各种计算流程信手拈来，而是一个靠谱的结构。往往一个靠谱的结构，你的计算就已经成功了90%，这么说一点也不为过。一个“垃圾”结构，你往往算了几天、一周、一个月，得到的结果都不见得令人满意。</p>
<p>如何得到一个靠谱的结构，或者说到哪里去找一个靠谱的结构，这里不得不介绍一下本期嘉宾——<a href="https://next-gen.materialsproject.org/">Materials Project</a>网站（下面简称MP）。截至到今天，MP提供了超过15万个无机化合物的结构信息以及性质，其中有实验已经发现的材料，也有纯计算预测的新材料。每一种化合物的计算源文件都可以免费下载本地，特别适合小白们自学VASP。</p>
<p><strong>当然，最重要的一点是，免费！免费！免费！Free~~~~~~~</strong></p>
<p>你只需要邮箱登录后就可以尽情使用</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/0_MP_login.png" alt="Materials Project_login"></p>
<p>登录后进入主页，开始今天的MP学习之旅。</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/1_MP_homepage.png" alt="MP_home"></p>
<h2 id="Materials-Project网页端"><a href="#Materials-Project网页端" class="headerlink" title="Materials Project网页端"></a>Materials Project网页端</h2><h3 id="材料检索"><a href="#材料检索" class="headerlink" title="材料检索"></a>材料检索</h3><p>MP上面材料的检索方式有三种:</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/3_MP_search_type.png" alt="MP_search_type"></p>
<ul>
<li><code>Only Elements</code>: 仅包含选定元素，如输入<code>Si</code>检索出来的结构只是单质硅；</li>
<li><code>At least Elements</code>: 至少包含选定元素，如输入<code>Si</code>检索出来的结构既有单质硅，也有含<code>Si</code>的化合物：<code>SiO</code>、<code>SiO2</code>等；</li>
<li><code>Formula</code>: 输入完整的分子式，如输入<code>SiO2</code>，检索出来的结构只有<code>SiO2</code>。</li>
</ul>
<p>这里我们用<code>Only Elements</code>检索<code>Si</code>，可以得到一系列的<code>Si</code>单质结构。</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/4_MP_Si.png" alt="MP_search_Si"></p>
<p>这么多<code>Si</code>单质结构，到底哪个是我们想要的呢？我们可以根据<code>Crystal System</code>、<code>Spacegroup</code>等信息筛选，这里我们以第一个<code>Si</code>结构为例，了解一下MP上面提供了哪些信息。</p>
<h3 id="页面信息"><a href="#页面信息" class="headerlink" title="页面信息"></a>页面信息</h3><p><code>Summary</code>一栏基本提供了晶体结构的常见基本信息：MP编号(mp-149)、空间群信息、能带信息、磁性信息、实验上是否得到等。</p>
<div class="note info flat"><p>MP编号相当于材料的身份证，是Materials Project网站上每一个材料的唯一标识符，在后续会用到。</p>
</div>

<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/5_MP_Si_info1.png" alt="MP_Si_info1"></p>
<p>继续往下拉还可以看到具体的晶格常数信息，能带态密度图、模拟光谱信息等。</p>
<ul>
<li>晶格常数信息</li>
</ul>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/6_MP_Si_info2.png" alt="MP_Si_info2"></p>
<ul>
<li>能带态密度图</li>
</ul>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/7_MP_Si_info3.png" alt="MP_Si_info3"></p>
<ul>
<li>模拟光谱</li>
</ul>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/8_MP_Si_info4.png" alt="MP_Si_info4"></p>
<p>MP上面还有很多其他信息，大家可以自行探索，这里就不一一介绍了。</p>
<h2 id="MP-API接口"><a href="#MP-API接口" class="headerlink" title="MP-API接口"></a>MP-API接口</h2><p>MP网页端的优势在于可以直观地看到材料的结构，但是从获取信息的角度来说，效率还是太低了。因此，MP还提供了API接口，可以方便地大批量获取到材料的结构、性质等各种信息。尤其适用于data mining、机器学习等领域。Anyway，即使你没有大规模数据下载分析的需求，对于日常使用来说，API接口用来找结构，查询信息还是很方便的。</p>
<h3 id="如何使用Materials-Project-API"><a href="#如何使用Materials-Project-API" class="headerlink" title="如何使用Materials Project API"></a>如何使用Materials Project API</h3><p>使用API接口非常简单，只需要几步即可。</p>
<ul>
<li>获取API key<br>在MP网页端注册账号，登录后，点击右上角的<code>API</code>，选择<code>API Key</code>，生成API Key即可，该字符串可复制保存，可长期使用。</li>
</ul>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/2_MP_api_key.png" alt="MP_API_key"></p>
<ul>
<li>安装mp_api包</li>
</ul>
<p>获取API key后，我们需要安装<code>mp_api</code>包，该包是Materials Project API的Python封装。后续的操作都需要在Python环境中进行，这个时候回到终端环境，激活<code>my_pymatgen</code>环境，可直接pip命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate my_pymatgen</span><br><span class="line">pip install mp_api</span><br><span class="line">pip show mp_api</span><br></pre></td></tr></table></figure>
<p>出现下面类似信息说明安装成功：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/9_mp_api_install.png" alt="mp_api_install"></p>
<ul>
<li>实例1：获取<code>Si</code>单质结构信息<br>python脚本的编写推荐使用IDE工具，如VSCode、PyCharm等，或者Jupyter Notebook。下面的操作均以Jupyter Notebook为例，如果您不熟悉Jupyter Notebook，可以参考<a href="https://jupyter.org/documentation">Jupyter Notebook官方文档</a>。</li>
</ul>
<p>如果没有安装Jupyter Notebook，可以先安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge notebook</span><br></pre></td></tr></table></figure>
<p>然后在终端运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>会跳转到外部页面，此时新建一个Jupyter Notebook文件，test.ipynb打开，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;aaaaabbbbb&quot;</span>  <span class="comment"># 请替换成你的API key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    <span class="comment"># 获取Si单质结构信息</span></span><br><span class="line">    structure = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(structure)          <span class="comment"># 打印结构信息</span></span><br></pre></td></tr></table></figure>
<p>这里我们是通过MP编号<code>mp-149</code>获取了<code>Si</code>单质结构信息，正如前文所说，MP编号相当于材料的身份证，是Materials Project网站上每一个材料的唯一标识符。</p>
<p>在Jupyter Notebook中运行代码命令为<code>Shift+Enter</code>，运行后会出现输出结果：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/10_case1.png" alt="MP_API_Si_structure"></p>
<div class="note info flat"><p>无论是Jupyter Notebook还是VSCode，输出结果都是一样的。</p>
</div>

<h3 id="检索材料信息"><a href="#检索材料信息" class="headerlink" title="检索材料信息"></a>检索材料信息</h3><h4 id="实例1：根据MP编号获取材料信息"><a href="#实例1：根据MP编号获取材料信息" class="headerlink" title="实例1：根据MP编号获取材料信息"></a>实例1：根据MP编号获取材料信息</h4><p>有人会说了，好像只打印出了一些简单的结构信息，并没有网页端的数据完整。别急，让我们丰富一下输出内容。MP-API提供了查询结构信息的方法<code>MPRester.materials.summary.search()</code>，通过这个函数方法，我们可以批量准确的查询到所需的材料信息，完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;aaaaabbbbb&quot;</span>  <span class="comment"># 请替换成你的API key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        material_ids=<span class="string">&#x27;mp-149&#x27;</span>,</span><br><span class="line">        fields=[<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;density&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">data = []               <span class="comment"># 空列表用于储存结果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">    symmetry_info = doc.symmetry</span><br><span class="line">    data.append(&#123;</span><br><span class="line">        <span class="string">&quot;band_gap&quot;</span>: doc.band_gap,</span><br><span class="line">        <span class="string">&quot;density&quot;</span>: doc.density,</span><br><span class="line">        <span class="string">&quot;formula_pretty&quot;</span>: doc.formula_pretty,</span><br><span class="line">        <span class="string">&quot;symbol&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;symbol&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;crystal_system&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;crystal_system&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;space_group_num&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;NONE&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)  <span class="comment"># 转换为DataFrame格式</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<p>初次看到这个代码，可能会有点晕，不过不要着急，慢慢看，我们一步一步来。这个代码的逻辑主要分为两步：</p>
<ul>
<li>1、调用api接口采用<code>MPRester.materials.summary.search()</code>查询编号为<code>mp-149</code>的材料具体信息，这里指定的字段有<code>band_gap</code>、<code>density</code>、<code>formula_pretty</code>、<code>symmetry</code>，分别表示带隙、密度、分子式、空间群信息：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        material_ids=<span class="string">&#x27;mp-149&#x27;</span>,</span><br><span class="line">        fields=[<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;density&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>这里fields参数可以指定需要查询的参数，也可以不指定，默认会返回所有参数。<code>MPRester.materials.summary.search()</code>可以查询的参数详情可参考<a href="https://materialsproject.github.io/api/_modules/mp_api/client/routes/materials/summary.html">官方文档</a></p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/11_search_details.png" alt="MP_API_search_fields"></p>
<p>上述即为部分参数，每个参数表示的意义基本就是英文直译，另有不懂的也可以在文档中找到具体的说明。</p>
<p>回到代码，<code>docs</code>是一个列表，存储了我们制定的<code>fields</code>参数的信息，但是此时直接<code>print(docs)</code>输出的结果不利于查看，如果我们直接<code>print(docs)</code>，会看到：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/12_prindocs.png" alt="MP_print_docs"></p>
<p>可以看到除了指定的参数，为写入<code>fields</code>的参数也会列出来，这样得到的结果老司机看到就头大，所以我们需要对其进行处理。</p>
<ul>
<li>2、使用pandas库将查询结果转换为DataFrame格式并输出，也就是第二段代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = []               <span class="comment"># 空列表用于储存结果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">    symmetry_info = doc.symmetry</span><br><span class="line">    data.append(&#123;</span><br><span class="line">        <span class="string">&quot;band_gap&quot;</span>: doc.band_gap,</span><br><span class="line">        <span class="string">&quot;density&quot;</span>: doc.density,</span><br><span class="line">        <span class="string">&quot;formula_pretty&quot;</span>: doc.formula_pretty,</span><br><span class="line">        <span class="string">&quot;symbol&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;symbol&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;crystal_system&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;crystal_system&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;space_group_num&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;NONE&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">df = pd.DataFrame(data)  <span class="comment"># 转换为DataFrame格式</span></span><br></pre></td></tr></table></figure>

<p>上述代码第2-11行用for循环遍历<code>docs</code>列表，将对应的属性储存在<code>data</code>列表中，具体提取的信息包括：</p>
<ul>
<li>band_gap: 材料的带隙</li>
<li>density: 材料的密度</li>
<li>formula_pretty: 材料的化学式</li>
<li>symbol: 材料的空间群信息。使用getattr函数获取属性值，如果属性不存在，则使用默认值”NONE”。</li>
<li>crystal_system: 材料的晶系（crystal system）。使用getattr函数获取属性值，如果属性不存在，则使用默认值”NONE”。</li>
<li>space_group_num: 材料的空间群编号（space group number）。使用getattr函数获取属性值，如果属性不存在，则使用默认值”NONE”。</li>
</ul>
<p>这里采用了getattr函数来提取<code>doc.symmetry</code>中的属性值，原因是因为<code>doc.symmetry</code>是一个字典，里面包含了多个属性，上述的<code>symbol</code>、<code>crystal_system</code>、<code>space_group_num</code>都是字典的键值。</p>
<p>第12行将<code>data</code>列表转换为DataFrame格式，运行print(df)后，可以得到如下结果：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/13_Si.png" alt="MP_API_Si_structure_df"></p>
<p>此次，我们通过MP-API根据MP编号获取了结构信息，并将其转换为DataFrame格式，方便后续分析，下面我们再试一下更有意思的玩法。</p>
<h4 id="实例2：根据元素获取材料信息"><a href="#实例2：根据元素获取材料信息" class="headerlink" title="实例2：根据元素获取材料信息"></a>实例2：根据元素获取材料信息</h4><p>在上述代码的基础上，修改检索的条件，将通过MP编号获取改成通过元素获取材料信息，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        elements=[<span class="string">&#x27;Si&#x27;</span>,<span class="string">&#x27;O&#x27;</span>],</span><br><span class="line">        fields=[<span class="string">&quot;material_id&quot;</span>,<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;density&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>其余代码保持不变，运行代码后，可以得到如下结果：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/14_contain_SiO.png" alt="contain_SiO"></p>
<p>可以看到，这一次直接返回了所有含有<code>Si</code>和<code>O</code>元素的材料信息，一共有7637个结构。但是，如果我们并不想看到所有材料信息，而是只想看到其中只包含<code>Si</code>和<code>O</code>元素的材料信息，这时候我们需要继续添加筛选条件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        elements=[<span class="string">&#x27;Si&#x27;</span>,<span class="string">&#x27;O&#x27;</span>],</span><br><span class="line">        fields=[<span class="string">&quot;material_id&quot;</span>,<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;density&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>],</span><br><span class="line">        num_elements=<span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>num_elements</code>参数限制了返回结果中的元素只有两种，即只包含Si和O的材料。运行代码后，可以得到如下结果：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/15_contain_SiO_num2.png" alt="contain_SiO_num2"></p>
<p>可以看到此时筛选得到的结构只有343个结构了。至此，大家应该明白了，MP-API的强大之处在于可以根据各种条件筛选材料信息，并进一步分析。根据不同的需求，只需要调节对应的限制参数，就可以得到所需的材料信息。如上述筛选条件还可以修改成：</p>
<ul>
<li>2 ≤ 元素种类 ≤ 4</li>
<li>至少含有<code>Si</code>和<code>O</code>元素</li>
<li>带隙大于1.5的材料</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        elements=[<span class="string">&#x27;Si&#x27;</span>,<span class="string">&#x27;O&#x27;</span>],</span><br><span class="line">        fields=[<span class="string">&quot;material_id&quot;</span>,<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;density&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>],</span><br><span class="line">        num_elements=(<span class="number">2</span>,<span class="number">4</span>),</span><br><span class="line">        band_gap=(<span class="number">1.5</span>,<span class="literal">None</span>)</span><br><span class="line">    )</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>运行代码后，可以得到如下结果：</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/16_contain_SiO_3.png" alt="contain_SiO_3"></p>
<h4 id="实例3：小练习"><a href="#实例3：小练习" class="headerlink" title="实例3：小练习"></a>实例3：小练习</h4><p>相信如果全程跟着老司机一起操作的话，应该对如何筛选有了一定了解，可以自行尝试一下下面的筛选条件：</p>
<ul>
<li>元素种类 ≥ 3</li>
<li>含有<code>O</code>元素</li>
<li>不含有：Fe、Co、Ni元素</li>
<li>0.5 ≤ 带隙值 ≤ 1</li>
<li>输出晶格常数abc</li>
<li>输出空间群信息</li>
</ul>
<p>结果如下，可以自行对照检验：<br><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/17_ex1_results.png" alt="ex1_result"></p>
<mark class="hl-label blue">参考代码</mark>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;aaaaaabbbbbbb&quot;</span>  <span class="comment"># 请替换成你的API key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        elements=[<span class="string">&#x27;O&#x27;</span>],</span><br><span class="line">        exclude_elements=[<span class="string">&#x27;Fe&#x27;</span>,<span class="string">&#x27;Co&#x27;</span>,<span class="string">&#x27;Ni&#x27;</span>],</span><br><span class="line">        fields=[<span class="string">&quot;material_id&quot;</span>,<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;structure&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>],</span><br><span class="line">        num_elements=(<span class="number">3</span>,<span class="literal">None</span>),</span><br><span class="line">        band_gap=(<span class="number">0.5</span>,<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">data = []               <span class="comment"># 空列表用于储存结果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">    symmetry_info = doc.symmetry</span><br><span class="line">    structure_info = doc.structure</span><br><span class="line">    data.append(&#123;</span><br><span class="line">        <span class="string">&quot;mp-id&quot;</span>: doc.material_id,</span><br><span class="line">        <span class="string">&quot;band_gap&quot;</span>: doc.band_gap,</span><br><span class="line">        <span class="string">&quot;formula_pretty&quot;</span>: doc.formula_pretty,</span><br><span class="line">        <span class="string">&quot;symbol&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;symbol&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: structure_info.lattice.a,</span><br><span class="line">        <span class="string">&quot;b&quot;</span>: structure_info.lattice.b,</span><br><span class="line">        <span class="string">&quot;c&quot;</span>: structure_info.lattice.c,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)  <span class="comment"># 转换为DataFrame格式</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h3 id="导出检索结果"><a href="#导出检索结果" class="headerlink" title="导出检索结果"></a>导出检索结果</h3><p>DateFrame格式的材料信息，可以方便的进行分析和处理，但是如果需要将结果导出为其他格式，比如csv文件，这时候就需要用到pandas的to_csv()方法，上述代码最后加入如下一行代码即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.to_csv(<span class="string">&quot;result.csv&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Export result to result.csv&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码后，会在当前目录下生成<code>result.csv</code>文件，打开csv文件后就可以看到检索结果了。</p>
<p><img src="/2024/05/30/Learn-VASP-from-pymatgen-3/18_csv_result.png" alt="export_csv"></p>
<h3 id="下载结构cif文件"><a href="#下载结构cif文件" class="headerlink" title="下载结构cif文件"></a>下载结构cif文件</h3><p>如果下载上述csv文件的所有结构的cif文件，可以运行如下代码：</p>
<mark class="hl-label blue">该代码会下载4000+个cif结构，请谨慎运行！！</mark>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;aaaaaabbbbbb&quot;</span>  <span class="comment"># 请替换成你的API key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    docs = mpr.materials.summary.search(</span><br><span class="line">        elements=[<span class="string">&#x27;O&#x27;</span>],</span><br><span class="line">        exclude_elements=[<span class="string">&#x27;Fe&#x27;</span>,<span class="string">&#x27;Co&#x27;</span>,<span class="string">&#x27;Ni&#x27;</span>],</span><br><span class="line">        fields=[<span class="string">&quot;material_id&quot;</span>,<span class="string">&quot;band_gap&quot;</span>, <span class="string">&quot;structure&quot;</span>,<span class="string">&quot;formula_pretty&quot;</span>, <span class="string">&quot;symmetry&quot;</span>],</span><br><span class="line">        num_elements=(<span class="number">3</span>,<span class="literal">None</span>),</span><br><span class="line">        band_gap=(<span class="number">0.5</span>,<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">data = []               <span class="comment"># 空列表用于储存结果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">    symmetry_info = doc.symmetry</span><br><span class="line">    structure_info = doc.structure</span><br><span class="line">    data.append(&#123;</span><br><span class="line">        <span class="string">&quot;mp-id&quot;</span>: doc.material_id,</span><br><span class="line">        <span class="string">&quot;band_gap&quot;</span>: doc.band_gap,</span><br><span class="line">        <span class="string">&quot;formula_pretty&quot;</span>: doc.formula_pretty,</span><br><span class="line">        <span class="string">&quot;symbol&quot;</span>: <span class="built_in">getattr</span>(symmetry_info, <span class="string">&quot;symbol&quot;</span>, <span class="string">&quot;NONE&quot;</span>),</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: structure_info.lattice.a,</span><br><span class="line">        <span class="string">&quot;b&quot;</span>: structure_info.lattice.b,</span><br><span class="line">        <span class="string">&quot;c&quot;</span>: structure_info.lattice.c,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)  <span class="comment"># 转换为DataFrame格式</span></span><br><span class="line">df.to_csv(<span class="string">&quot;result.csv&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Export result to result.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有材料并下载其 CIF 文件</span></span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">        material_id = doc.material_id</span><br><span class="line">        structure = mpr.get_structure_by_material_id(material_id, final=<span class="literal">True</span>)</span><br><span class="line">        structure.to(<span class="string">f&quot;<span class="subst">&#123;material_id&#125;</span>.cif&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果只需要下载指定MP编号的cif文件，可以调用<code>get_structure_by_material_id</code>方法储存结构信息并写入到本地，这里我们下载<code>mp-149</code>的cif文件，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;aaaaaabbbbbb&quot;</span>  <span class="comment"># 请替换成你的API key</span></span><br><span class="line"></span><br><span class="line">mpid = <span class="string">&quot;mp-149&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    structure = mpr.get_structure_by_material_id(mpid, final=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    structure.to(<span class="string">f&quot;<span class="subst">&#123;mpid&#125;</span>.cif&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MP-API的介绍就到此为止啦~~~~<br>目前为止，介绍了如何调用API接口；如果根据需求检索材料并汇总成csv文件；以及最后根据需求下载cif文件。当然，MP-API还有很多功能，比如获取结构的电子结构、能量等信息，这里就不一一介绍了。更多功能详解有需求后面再单独补充介绍。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
        <tag>Materials Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.4  计算小白硬学VASP —— MPRelaxSet用法</title>
    <url>/2024/06/04/Learn-VASP-from-pymatgen-4/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>VASP计算运行流程简单示意图：</p>
<pre class="mermaid">flowchart LR
    input 
    vasp(vasp)
    converged(converged)
    raw_data(raw_data)
    
    subgraph prep_input
    1([INCAR])-->input
    2([KPOINTS])-->input
    3([POSCAR])-->input
    4([POTCAR])-->input
    5([sub_job.script])-->input
    end
    input-->vasp
    subgraph vasp_black_box
    vasp---relax([relax])-->converged
    vasp---scf_calc([scf_calc])-->converged
    vasp---nonscf_calc([nonscf_calc])-->converged
    vasp---ect([......])-->converged
    end
    converged-->raw_data
    subgraph post_processing
    raw_data-->table([table])
    raw_data-->gra([graph])
    raw_data-->animation([animation])
    
    end</pre>

<ul>
<li><p>第一步为输入文件的准备，除了准备<code>INCAR KPOINTS POSCAR POTCAR</code>这四个VASP必需的输入文件之外，通常使用超算集群的用户还需要准备任务提交脚本<code>sub_job.script</code>；</p>
</li>
<li><p>第二步为提交运行VASP进行计算，这里可以把软件运算过程当成一个黑匣子，作为使用者的角度，我们无需去了解它是如何迭代计算，只需要根据不同的计算内容，我们能够根据不同的依据来判断计算是否完成，也就是是否收敛；</p>
</li>
<li><p>第三步为数据后处理过程，VASP输出的输出一般都不能直接转化成为可用的结果，需要我们进一步去分析电荷文件、波函数文件、<code>OUTCAR</code>文件等，从其中得到我们最终可以绘图<code>or</code>制表的数据。</p>
</li>
</ul>
<h3 id="Why-pymatgen"><a href="#Why-pymatgen" class="headerlink" title="Why pymatgen"></a>Why pymatgen</h3><p>完整的计算流程中除了第二步依赖于软件本身，其余的工作都需要花费大量的人力时间来操作。传统操作来讲，输入文件可能用<code>vim</code>、<code>Notepad++</code>、<code>VScode</code>等手动编辑；计算结果的处理除了用插件得到<code>raw_data</code>还需要用到<code>origin</code>手动作图。</p>
<p>对于少量计算来说，手动的亲力亲为的效率反而更高，但是遇到大量计算的计算操作，比如高通量计算，人的专注度是有限的，很容易就会出问题，老司机踩过的坑就包括但不仅限于以下：</p>
<ul>
<li><p>修改后的<code>POSCAR</code>，忘记对应修改<code>POTCAR</code> </p>
</li>
<li><p>磁性体系没开<code>ISPIN</code></p>
</li>
<li><p>未收敛的结果继续做自洽计算</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>这些操作看起来非常的离谱，初学VASP的兄弟肯定会说这个太夸张了。相信我，经历过大量计算的老哥们肯定或多或少都踩过类似的坑。</p>
<p>回到正题，why pymatgen？看看下面的图你就知道：</p>
<p><img src="/2024/06/04/Learn-VASP-from-pymatgen-4/pmg_chart.png" alt="pmg_chart"></p>
<p>这个是<code>pymatgen</code>的功能示意图，不难发现，好像<code>pymatgen</code>把我们要干的活都给干了：</p>
<ul>
<li><p>支持根据计算类型生成输入文件</p>
</li>
<li><p>支持识别多种格式的结构文件</p>
</li>
<li><p>支持分析计算结果</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>配合上<code>matplotlib</code>绘图，妥妥的实现整个计算流程脚本自动化：</p>
<p>代码一年写一次，一次用三年。</p>
<h3 id="自动生成结构弛豫（优化）输入文件"><a href="#自动生成结构弛豫（优化）输入文件" class="headerlink" title="自动生成结构弛豫（优化）输入文件"></a>自动生成结构弛豫（优化）输入文件</h3><h4 id="MPRelaxSet-or-MPScanRelaxSet：如何选择合适的模块"><a href="#MPRelaxSet-or-MPScanRelaxSet：如何选择合适的模块" class="headerlink" title="MPRelaxSet or MPScanRelaxSet：如何选择合适的模块"></a>MPRelaxSet or MPScanRelaxSet：如何选择合适的模块</h4><p>本小节主要介绍下<code>pymatgen</code>中生成结构优化输入文件的模块的相关功能。看标题老司机给出了两个模块，这两个模块都是用于生成结构优化的输入文件，但是使用场景却有些许差别，需要根据使用场景和个人需求来自主选择。</p>
<p>总所周知，<code>pymatgen</code>就是由<code>Materials Project</code>的团队开发的，而<code>Materials Project</code>上的结构的相关数据也都是通过<code>pymatgen</code>的生成的输入来进行计算而得到。</p>
<p>那么问题来了，<code>Materials project</code>2011年就成立了，受限于当时的计算资源，面对如此庞大的高通量计算，当时的计算参数的设置稍显粗糙，放在如今的精度评判标准来看显然是不够的。为此官方也多次在<code>Github</code>的Issue里面提到过网页端的数据目前看来部分是<code>outdated</code>，但是官网也会定期的更新<code>datebase</code>，有兴趣可以看下每个版本都更新了哪些数据 <a href="https://docs.materialsproject.org/changes/database-versions">link</a>。而已有的数据绝大部分都是基于<code>MPRelaxSet</code>模块优化的结构计算的。</p>
<p>下面是两个模块分别针对<code>Si</code>单质生成的<code>INCAR</code>词条对比：</p>
<p><img src="/2024/06/04/Learn-VASP-from-pymatgen-4/Si_oldINCAR-17177292067111.png" alt="Si_oldINCAR">           <img src="/2024/06/04/Learn-VASP-from-pymatgen-4/Si_newINCAR.png" alt="Si_newINCAR"></p>
<p>不用去管每个词条是什么意思，单看词条数量，俗话说：”一寸长，一寸强“，单从词条的长度就可以大致凭借经验判断，短的可能精度比较低，没错，短的就是<code>MPRelaxSet</code>生成的。</p>
<p>那么是不是说明<code>MPRelaxSet</code>就不能用了呢？大可不必直接否定。</p>
<h5 id="MPRelaxSet默认参数适用场景"><a href="#MPRelaxSet默认参数适用场景" class="headerlink" title="MPRelaxSet默认参数适用场景"></a>MPRelaxSet默认参数适用场景</h5><ul>
<li><p>相图计算</p>
<p>相图的计算需要设计许多中间相结构的计算，而<code>Materials project</code>作为数据库已经记录了许多结构的标准化输入的能量，这些数据都是可以直接调用的，因此对我们计算相图提供了极大的便利。基于此，我们在补充结构进行计算时，也需要保持<code>Materials project</code>数据的默认设置，所以此时调用<code>MPRelaxSet</code>模块是相对合适的；</p>
</li>
<li><p>电化学窗口</p>
<p>同理电化学窗口的计算也需要计算大量的结构。为此，这类需要调用<code>Materials project</code>上面结构能量数据来节省计算量的，可以使用<code>MPRelaxSet</code>模块；</p>
</li>
<li><p>粗收敛</p>
<p>我们之前说过，好的结构是好结果的关键，那么其中重要的步骤就是优化过程。对于复杂结构：异质结、磁性体系、超大模型等，采用<code>MPRelaxSet</code>模块进行粗收敛来初步判断结构建模以及参数设置是否合理，同时不失为一个节省计算总时长的好办法。</p>
</li>
</ul>
<p>如果需要对应<code>Materials project</code>上的结构数据，势函数的种类选择也要对应，这里先提一下留意一下，后面详细说明。</p>
<h5 id="MPScanRelaxSet介绍"><a href="#MPScanRelaxSet介绍" class="headerlink" title="MPScanRelaxSet介绍"></a>MPScanRelaxSet介绍</h5><p><code>MPScanRelaxSet</code>模块的使用条件就比较限制了，软件方面的适用条件：</p>
<ul>
<li><p><code>VASP</code>版本6.0.0及以上</p>
</li>
<li><p>默认引入了更准确的<code>METAGGA = r2SCAN</code>方法，此方法要求<code>VASP</code>版本6.2及以上</p>
</li>
<li><p><code>METAGGA</code>要求势函数包含<code>kinetic energy density of the core-electrons</code>，也就是势函数必须要用<code>PBE_52</code>及以上版本</p>
<p>看到这里是否有点不知道在讲什么，其实老司机也只是把文档的内容汉化成以上三点，平常我也是使用的<code>MPRelaxSet</code>模块，因为目前我使用的VASP版本还是5.4.4 <code>QAQ</code></p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里，老司机建议先使用<code>MPRelaxSet</code>模块就足够了，对于目前大部分<code>pymatgen</code>的用户来说，<code>MPRelaxSet</code>模块的使用还是占主要的。而且也不必担心计算精度问题，既然模块有默认参数，那么在使用过程中我们也可以根据需求进行调整精度。后续的计算也是基于<code>VASP_v5.4.4</code>，用<code>MPRelaxSet</code>模块实例。</p>
<p><em><strong>PS：</strong></em>其实就是老司机使用的服务器没有<code>VASP_v6.0+</code>版本，不然高低也得详细对比测一下，给出更详细的使用建议。</p>
<h4 id="MPRelaxSet使用实例"><a href="#MPRelaxSet使用实例" class="headerlink" title="MPRelaxSet使用实例"></a>MPRelaxSet使用实例</h4><h5 id="实例1：生成Si单质结构优化输入文件"><a href="#实例1：生成Si单质结构优化输入文件" class="headerlink" title="实例1：生成Si单质结构优化输入文件"></a>实例1：生成Si单质结构优化输入文件</h5><p><code>MPRelaxSet</code>模块调用命令是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br></pre></td></tr></table></figure>

<p><code>sets</code>里还包含其他模块，除上面的<code>MPScanRelaxSet</code>，还有<code>LobsterSet</code>、<code>MPAbsorptionSet</code>、<code>MPHSEBSSet</code>等等，后续有需要会一一介绍。</p>
<p>导入模块之后，我们必须提供的只有结构信息，而读取结构信息还需要用到的模块是<code>Structure</code>，同样也需要导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br></pre></td></tr></table></figure>

<h6 id="输入结构信息"><a href="#输入结构信息" class="headerlink" title="输入结构信息"></a>输入结构信息</h6><p><code>Structure</code>支持的结构信息类型非常多可以自己写，也可以只提供提供文件路径供识别：</p>
<ul>
<li>手写晶格常数，元素种类，原子坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Lattice</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 晶格常数</span></span><br><span class="line">lattice = Lattice([[<span class="number">4.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">4.2</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#原子种类</span></span><br><span class="line">species = [<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#原子坐标</span></span><br><span class="line">coords = [[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Si结构</span></span><br><span class="line">struct = Structure(lattice, species, coords)</span><br></pre></td></tr></table></figure>

<p>但是该方法极不推荐，why，因为很麻烦，而且复杂结构的原子坐标根本写不出来，但是对于单原子的结构建模，还是可以使用。</p>
<ul>
<li>提供现成结构文件，目前可以识别的格式有：</li>
</ul>
<ol>
<li><p>Crystallographic Information Format file (.cif文件)</p>
</li>
<li><p>VASP输入输出中包含结构信息的文件：POSCAR、CONTCAR、CHGCAR、LOCPOT、vasprun.xml</p>
</li>
<li><p>CSSR、Netcdf、pymatgen结构JSON文件</p>
</li>
</ol>
<p>前两种的结构文件是比较常见的，也是常用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构文件路径</span></span><br><span class="line">poscar = <span class="string">&quot;./POSCAR&quot;</span>		<span class="comment">#当前文件夹下有POSCAR文件</span></span><br><span class="line"></span><br><span class="line">struct = Structure.from_file(poscar)	<span class="comment">#from_file用法是固定的，用于读取该路径下的结构文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MP-API获取结构：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    struct = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>) <span class="comment"># Si的MP编号</span></span><br></pre></td></tr></table></figure>

<p>这里Si的结构信息就被储存到<code>structure</code>变量了</p>
<h6 id="MPRelaxSet生成并导出输入文件"><a href="#MPRelaxSet生成并导出输入文件" class="headerlink" title="MPRelaxSet生成并导出输入文件"></a>MPRelaxSet生成并导出输入文件</h6><p>结构准备好了之后，就可以直接生成输入文件了，下面是完整代码：</p>
<mark class="hl-label blue">参考代码</mark>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.core <span class="keyword">import</span> Lattice</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法1</span></span><br><span class="line"><span class="comment"># 晶格常数</span></span><br><span class="line">lattice = Lattice([[<span class="number">4.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">4.2</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.2</span>]])</span><br><span class="line"><span class="comment">#原子种类</span></span><br><span class="line">species = [<span class="string">&quot;Si&quot;</span>, <span class="string">&quot;Si&quot;</span>]</span><br><span class="line"><span class="comment">#原子坐标</span></span><br><span class="line">coords = [[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]]</span><br><span class="line"><span class="comment">#创建Si结构</span></span><br><span class="line">struct1 = Structure(lattice, species, coords)</span><br><span class="line"><span class="comment">#调用MPRelaxSet</span></span><br><span class="line">relax1 = MPRelaxSet(struct1)</span><br><span class="line"><span class="comment">#导出文件</span></span><br><span class="line">relax1.write_input(<span class="string">&#x27;./1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件成功保存到1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##方法2</span></span><br><span class="line"><span class="comment"># 结构文件路径</span></span><br><span class="line">Si_poscar = <span class="string">&quot;./POSCAR&quot;</span>		<span class="comment">#当前文件夹下准备Si的POSCAR文件</span></span><br><span class="line">struct2 = Structure.from_file(Si_poscar)</span><br><span class="line"><span class="comment">#调用MPRelaxSet</span></span><br><span class="line">relax2 = MPRelaxSet(struct2)</span><br><span class="line"><span class="comment">#导出文件</span></span><br><span class="line">relax2.write_input(<span class="string">&#x27;./2&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件成功保存到2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##方法3</span></span><br><span class="line">api_key = <span class="string">&quot;aaaaabbbbb&quot;</span>	<span class="comment">#换成你的key</span></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    struct3 = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>)</span><br><span class="line">    relax3 = MPRelaxSet(struct3)</span><br><span class="line">    <span class="comment">#导出文件</span></span><br><span class="line">	relax3.write_input(<span class="string">&#x27;./3&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件成功保存到3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><img src="/2024/06/04/Learn-VASP-from-pymatgen-4/Sirelax_input.png" alt="Sirelax_input"></p>
<p>当前路径生成三个文件夹，每个文件夹对于不同方法生成的输入文件，可以发现其中的<code>INCAR</code>几乎是一样的，除了方法3中<code>INCAR</code>的原子初始磁矩<code>MAGMOM</code>都设置成0了，这是因为方法3是直接读取的<code>Materials project</code>的数据，直接包含了磁矩信息，覆盖了默认设置。</p>
<p><img src="/2024/06/04/Learn-VASP-from-pymatgen-4/Si_incar_compare.png" alt="Si_incar_compare"></p>
<h5 id="实例2：自定义输入参数（进阶设置）"><a href="#实例2：自定义输入参数（进阶设置）" class="headerlink" title="实例2：自定义输入参数（进阶设置）"></a>实例2：自定义输入参数（进阶设置）</h5><p>前面我们讲了<code>MPRelaxSet</code>的默认参数精度是比较低的，正常来说，默认计算后得到的结构和能量数据都不建议使用。但是，不用担心，我们可以自定义输入参数，包括截断能、收敛标准，优化步数等等。</p>
<p>虽然前面讲过不需要去学习参数词条就可以学会VASP计算。严格来说实例1学会之后，任何结构你都可以生成输入去用VASP算一下看看结果。</p>
<p>本实例也可以说是进阶内容，主要是利于针对每个人自己对应的研究体系，能够设置相对合理的参数，需要对基本的<code>INCAR</code>词条有一定了解。</p>
<p>所以对该部分不感兴趣的可以直接跳过本小节，后面再看也可以。</p>
<h6 id="user-incar-settings"><a href="#user-incar-settings" class="headerlink" title="user_incar_settings"></a>user_incar_settings</h6><p>之前的代码中，<code>MPRelaxSet</code>中我们只提供了结构，如果是用于自定义INCAR参数，还可以继续添加<code>user_incar_settings</code>来覆盖默认的设置，这里不需要写完整的所有INCAR设置，只需要写你想要改变的词条。</p>
<p><code>INCAR</code>词条有默认的设置，即使不写入<code>INCAR</code>里面也会在计算中采用默认的设置，详情默认设置的值以及解释见[VASP官网](<a href="https://www.vasp.at/wiki/index.php/The_VASP_Manual">The VASP Manual - VASP Wiki</a>)</p>
<p>语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line">Si_poscar = <span class="string">&quot;./POSCAR&quot;</span></span><br><span class="line">struct = Structure.from_file(Si_poscar)</span><br><span class="line">relax_old = MPRelaxSet(struct2)</span><br><span class="line">relax_new = MPRelaxSet(</span><br><span class="line">    struct2,</span><br><span class="line">    user_incar_settings=&#123;<span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>&#125;</span><br><span class="line">)</span><br><span class="line">relax_old.write_input(<span class="string">&#x27;./old&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Default settings have been written&quot;</span>)</span><br><span class="line">relax_new.write_input(<span class="string">&#x27;./new&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;New settings have been added&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行后对比<code>new</code>和<code>old</code>文件夹里的<code>INCAR</code></p>
<p><img src="/2024/06/04/Learn-VASP-from-pymatgen-4/add_EDIFFG.png" alt="add_EDIFFG"></p>
<p>成功添加了<code>EDIFFG</code>词条，此时控制结构收敛的标准从能量收敛变成了更为严格靠谱的力收敛。</p>
<p>如果想修改更多的词条，我们也只需要在<code>user_incar_settings</code>对应的字典后面逐个添加即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_incar_settings=&#123;</span><br><span class="line">    <span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&#x27;ENCUT&#x27;</span>:<span class="number">400</span>,</span><br><span class="line">    <span class="string">&#x27;NSW&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="string">&#x27;ISPIN&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;ALGO&#x27;</span>:<span class="string">&#x27;Normal&#x27;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="user-kpoints-settings"><a href="#user-kpoints-settings" class="headerlink" title="user_kpoints_settings"></a>user_kpoints_settings</h6><p>说完了<code>INCAR</code>的自定义设置，<code>KPOINTS</code>的自定义设置也类似。</p>
<ul>
<li>调用<code>Kpoints</code>模块来生成</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.inputs <span class="keyword">import</span> Kpoints</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment"># 1.指定K点</span></span><br><span class="line">kpoints = Kpoints(kpts=[(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.全自动K空间网格</span></span><br><span class="line">kpoints = Kpoints.automatic(<span class="number">50</span>)	<span class="comment"># 50表示倒格子空间向量长度与分隔的K点的乘积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.根据K点密度自动生成</span></span><br><span class="line">kpoints = Kpoints.automatic_density(struct, <span class="number">1000</span>) <span class="comment"># 1000表示K空间里整个K点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.与2类似，指定每条向量</span></span><br><span class="line">kpoints = Kpoints.automatic_density_by_lengths(struct, [<span class="number">50</span>,<span class="number">50</span>,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.根据体积平均生成K点</span></span><br><span class="line">kpoints = Kpoints.automatic_density_by_vol(struct,<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">relax_new = MPRelaxSet(</span><br><span class="line">    struct,</span><br><span class="line">    user_incar_settings=&#123;<span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>&#125;,</span><br><span class="line">    user_kpoints_settings=kpoints</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">强烈推荐1和2方法</mark>

<ul>
<li><p>修改<code>MPRelaxSet</code>默认KPOINTS设置</p>
<p>在之前的代码中，我们并没有进行K点的相关设置，但是生成的输入文件中也给我们生成了<code>KPOINTS</code>文件。查阅官网文档内容可以发现，实际上K点的设置是已经给我们设置了默认的参数：<code>&#123;&#39;reciprocal_density&#39;: 64&#125;</code>，此外还有其他的设置方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># 倒格子密度</span></span><br><span class="line">kpoints = &#123;<span class="string">&#x27;reciprocal_density&#x27;</span>: <span class="number">64</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格密度</span></span><br><span class="line">kpoints = &#123;<span class="string">&#x27;grid_density&#x27;</span>: <span class="number">500</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全自动K点</span></span><br><span class="line">kpoints = &#123;<span class="string">&#x27;length&#x27;</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">relax_new = MPRelaxSet(</span><br><span class="line">    struct,</span><br><span class="line">    user_incar_settings=&#123;<span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>&#125;,</span><br><span class="line">    user_kpoints_settings=kpoints</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>除上述外，官方支持的全部格式如下：</p>
<ol>
<li><p><code>&#39;grid_density&#39;</code> for Kpoints.automatic_density generation </p>
</li>
<li><p><code>&#39;reciprocal_density&#39;</code> for KPoints.automatic_density_by_vol generation</p>
</li>
<li><p><code>&#39;length&#39;</code> for Kpoints.automatic generation</p>
</li>
<li><p><code>&#39;line_density&#39;</code> for line mode generation</p>
</li>
<li><p><code>&#39;added_kpoints&#39;</code> for specific k-points to include</p>
</li>
<li><p><code>&#39;zero_weighted_reciprocal_density&#39;</code> for a zero weighted uniform mesh</p>
</li>
<li><p><code>&#39;zero_weighted_line_density&#39;</code> for a zero weighted line mode mesh</p>
</li>
</ol>
</li>
</ul>
<h6 id="user-potcar-settings"><a href="#user-potcar-settings" class="headerlink" title="user_potcar_settings"></a>user_potcar_settings</h6><p><code>POTCAR</code>的自定义设定主要是用于指定元素的势函数种类，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment"># pymatgen默认指定Li元素用Li_sv势，Na元素用Na_pv势，根据个人需求可改成调用普通的势</span></span><br><span class="line">potcar = &#123;</span><br><span class="line">    <span class="string">&#x27;Li&#x27;</span>:<span class="string">&#x27;Li&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Na&#x27;</span>：<span class="string">&#x27;Na&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relax_new = MPRelaxSet(</span><br><span class="line">    struct,</span><br><span class="line">    user_incar_settings=&#123;<span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>&#125;,</span><br><span class="line">    user_potcar_settings=potcar</span><br><span class="line">)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h6 id="user-potcar-functional"><a href="#user-potcar-functional" class="headerlink" title="user_potcar_functional"></a>user_potcar_functional</h6><p><code>MPRelaxSet</code>默认的函数指定的是<code>&#39;PBE&#39;</code>，前面说到，<code>MPRelaxSet</code>的相关设置都是比较落后的，在势函数上默认的选择也是比较老的<code>&#39;PBE&#39;</code>，尤其是目前vasp版本已经更新到了6.4了，势函数也更新到了<code>&#39;PBE_64&#39;</code>。</p>
<p>在上面的实操过程中，如果你的<code>&lt;PMG_VASP_PSP_DIR&gt;</code>路径下没有<code>&#39;PBE&#39;</code>势函数，可能会报错且没有文件生成：</p>
<p><code>You do not have the right POTCAR with functional=&#39;PBE&#39; and symbol=&#39;Si&#39; in your PMG_VASP_PSP_DIR</code></p>
<p>注意：这个并不是说咱的操作有问题，只是<code>MPRelaxSet</code>函数默认读取<code>&#39;PBE&#39;</code>，且<code>&#39;PBE&#39;</code>目前来说已经过时了。</p>
<p>因此在使用的时候，我们需要加上<code>user_potcar_functional</code>参数来指定我们使用的势函数，这里我用的是<code>&#39;PBE_54&#39;</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">relax_new = MPRelaxSet(</span><br><span class="line">    struct,</span><br><span class="line">    user_incar_settings=&#123;<span class="string">&#x27;EDIFFG&#x27;</span>:-<span class="number">0.01</span>&#125;,</span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>再次运行，可正常生成输入文件。</p>
<p>还没完！！！</p>
<p>运行完上述的命令，输入文件可以正常生成了，但是又有新的Warning：</p>
<blockquote>
<p><strong>BadInputSetWarning:</strong> Overriding the POTCAR functional is generally not recommended  as it significantly affect the results of calculations and compatibility with other calculations done with the same input set. Note that some POTCAR symbols specified in the configuration file may not be available in the selected functional.</p>
</blockquote>
<blockquote>
<p><strong>BadInputSetWarning:</strong> POTCAR data with symbol Si is not known by pymatgen to correspond with the selected user_potcar_functional&#x3D;’PBE_54’. This POTCAR is known to correspond with functionals [‘PBE_52_W_HASH’, ‘PBE_54_W_HASH’, ‘PBE_64’]. Please verify that you are using the right POTCARs!  warnings.warn(</p>
</blockquote>
<p><code>VASP</code>计算中有句话：Warning不算报错，能算就继续算。</p>
<p>这里也是一样，这个Warning并不表示你的参数设置有问题，而是<code>VASP</code>官方会随着版本更新，相应的也会更新势函数的版本，同样地，<code>pymatgen</code>在更新的时候的时候也会同步把新版的势函数的<code>hash</code>值加入进来以便识别。简而言之，这个warning就是提醒你目前推荐的势函数版本是什么，比如这里推荐的是<code>&#39;PBE_64&#39;</code>。当然并不是说明<code>&#39;PBE_54&#39;</code>的势函数就是错的。官方<code>Github</code>的<code>Issue</code>里面有很多类似的讨论，这个Warning主要就是要提醒用户，了解自己在做什么。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>MPRelaxSet</code>的用法就介绍到这，本章干货满满，各位多多练习~~~~</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
        <tag>MPRelaxSet</tag>
        <tag>MPScanRelaxSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.5  计算小白硬学VASP —— 材料性质计算—&gt;态密度</title>
    <url>/2024/06/11/Learn-VASP-from-pymatgen-5/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>上一章我们主要分享了结构优化的输入文件的生成，以及自定义输入文件参数；本章简单介绍下，对于Bulk模型来说，各类性质计算的输入文章生成，以及参数设置要点。</p>
<h4 id="简单自洽计算"><a href="#简单自洽计算" class="headerlink" title="简单自洽计算"></a>简单自洽计算</h4><p>性质计算的前提是进行结构优化得到稳定的结构。对于不同的性质计算，计算的步骤往往需要多步进行，例如态密度计算，需要先进行自洽计算得到电荷、波函数文件，然后再进行一步非自洽计算。</p>
<p>首先介绍下普通的自洽计算，用于得到电荷、波函数文件。</p>
<h5 id="调用MPStaticSet"><a href="#调用MPStaticSet" class="headerlink" title="调用MPStaticSet"></a>调用MPStaticSet</h5><p>自洽计算的输入文件生成可以调用<code>MPStaticSet</code>模块，以<code>Si</code>为例，默认生成输入文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPStaticSet</span><br><span class="line"></span><br><span class="line">static = MPStaticSet.from_prev_calc(</span><br><span class="line">    <span class="comment"># 上一步优化的文件夹</span></span><br><span class="line">    prev_calc_dir=<span class="string">&#x27;./relax&#x27;</span>,</span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static.write_input(<span class="string">&#x27;./static&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;static_calc is ready!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>从用法上来说<code>MPStaticSet</code>的用法跟<code>MPRelaxSet</code>类似。但是这里细心的可以发现，这里老司机并没有提供结构文件，而是用了<code>from_prev_calc</code>方法，顾名思义就是读取前一步计算的文件进行计算，这里读取的就是之前优化计算的文件夹。</p>
<p>该方法通用于所有<code>set</code>类的模块，例如之前介绍的<code>MPRelaxSet</code>模块也可以使用，区别就是现在需要提供的是你希望读取的上一步计算的路径。该操作简而言之就是<code>VASP</code>中的续算操作。</p>
<p>运行上述代码后，可以得到如下<code>static</code>的<code>INCAR</code>：</p>
<p><img src="/2024/06/11/Learn-VASP-from-pymatgen-5/staticVSrelax.png" alt="staticVSrelax"></p>
<p>与优化的<code>INCAR</code>对比可以发现，主要是修改了与优化有关的参数：<code>IBRION</code>、<code>NSW</code>；关于<code>ISMEAR</code>参数，<code>VASP</code>提供了比较友好的经验选择方法：</p>
<blockquote>
<ul>
<li><p>If you have no a priori knowledge of your system, for instance, if you do not know whether your system is an insulator, semiconductor or metal then always use Gaussian smearing ISMEAR&#x3D;0 in combination with a small <a href="https://www.vasp.at/wiki/index.php/SIGMA">SIGMA</a>&#x3D;0.03-0.05.</p>
</li>
<li><p>For semiconductors or insulators, use the tetrahedron method (ISMEAR&#x3D;-5), if the cell is too large (or if you use only a single or two <strong>k</strong> points) use ISMEAR&#x3D;0 in combination with a small <a href="https://www.vasp.at/wiki/index.php/SIGMA">SIGMA</a>&#x3D;0.03-0.05.</p>
</li>
<li><p>For relaxations <em>in metals</em>, use ISMEAR&#x3D;1 or ISMEAR&#x3D;2 and an appropriate <a href="https://www.vasp.at/wiki/index.php/SIGMA">SIGMA</a> value (the entropy term should be less than 1 meV per atom). For metals a reasonable value is often SIGMA&#x3D; 0.2 (which is the default).</p>
</li>
<li><p>For the calculations of the DOS and very accurate total-energy calculations (no relaxation in metals), use the tetrahedron method (ISMEAR&#x3D;-5).</p>
</li>
</ul>
</blockquote>
<p><strong>上述INCAR的设置为MPStaticSet的默认设置，针对具体性质计算，需要调整的词条参数不同</strong></p>
<h4 id="态密度计算"><a href="#态密度计算" class="headerlink" title="态密度计算"></a>态密度计算</h4><p>态密度计算需要先进行一步自洽计算，然后进行一步非自洽计算得到最终的态密度数据。在第一步的自洽计算我们只需要得到电荷文件<code>CHGCAR</code>和<code>CHG</code>就可以了（<code>WAVECAR</code>文件较大，且态密度非自洽计算可以不读<code>WAVECAR</code>），而上一步<code>MPStaticSet</code>默认输出电荷文件（<code>LCHARG = True</code>)，所以自洽计算的参数不用过多调整。下面主要介绍非自洽计算用到的模块。</p>
<h5 id="调用MPNonSCFSet"><a href="#调用MPNonSCFSet" class="headerlink" title="调用MPNonSCFSet"></a>调用MPNonSCFSet</h5><p>我们可以先看下<code>MPNonSCFSet</code>模块默认生成的<code>INCAR</code>是什么样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPNonSCFSet</span><br><span class="line"></span><br><span class="line">nonscf_dos = MPNonSCFSet.from_prev_calc(prev_calc_dir=<span class="string">&#x27;./static&#x27;</span>, user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>)</span><br><span class="line"></span><br><span class="line">nonscf_dos.write_input(<span class="string">&#x27;./dos&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DOS_calc is ready!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/11/Learn-VASP-from-pymatgen-5/dos_default_input.png" alt="dos_default_input"></p>
<p>默认的<code>INCAR</code>中增加<code>ICHARG</code>词条，当<code>ICHARG≥10</code>时，计算过程中电荷密度不进行自洽更新，<code>CHGCAR</code>和<code>CHG</code>文件内容不变，即非自洽计算。</p>
<p>态密度计算仅读<code>CHGCAR</code>即可，即只用复制<code>CHGCAR</code>至态密度计算文件夹。</p>
<p><strong>如果使用<code>MPNonSCFSet</code>的<code>from_prev_calc</code>方法，默认会复制上一步自洽计算的<code>CHGCAR</code>文件到当前文件夹；如果只用<code>MPNonSCFSet</code>，则需要指定结构文件<code>struct</code>，以及自行把<code>CHGCAR</code>复制到当前目录。</strong></p>
<h5 id="自定义参数设置"><a href="#自定义参数设置" class="headerlink" title="自定义参数设置"></a>自定义参数设置</h5><p>此外，本小节主要介绍<code>DOS</code>计算，默认的INCAR参数中，部分的设置是不太合理的，或者说不利于后续的数据分析。</p>
<p><strong>前面提到，<code>VASP</code>对许多词条的值有默认值，如果不在<code>INCAR</code>中覆写，计算采用的就是默认值</strong></p>
<ul>
<li><code>EMIN</code>：态密度能量下区间（默认值：<code>lowest KS-eigenvalue - Δ</code>）</li>
<li><code>EMAX</code>：态密度能量上区间（默认值：<code>lowest KS-eigenvalue - Δ</code>）</li>
<li><code>NEDOS</code>：态密度的网格点数（默认值：301）</li>
<li><code>ISPIN</code>：是否考虑电子自旋</li>
</ul>
<p>上述的三个参数根据作图需求进行调整，比如态密度图主要是分析费米能级附近的占据情况，实际计算时，默认的能量区间可能非常大，同时<code>NEDOS</code>的数值是确定的，所以会一定程度降低费米能级附近的精度。因此，如果你只需要费米能级附近的信息，可以在<code>INCAR</code>中指定能量区间，如<code>EMIN=-8</code>、<code>EMAX=8</code>，然后选取适当的<code>NEDOS</code>(推荐2001)，这样的话精度是比较合适的，作图也不会因为<code>NEDOS</code>数量过少而出现锯齿线条。<code>ISPIN</code>本身是控制体系是否考虑自旋，一般认为是与磁性计算有关，但是在态密度计算中，是否考虑自旋影响最后输出的数据是否把自旋向上的轨道与自旋向下的轨道区分开。</p>
<ul>
<li><code>LORBIT</code>：决定投影轨道的形式（常用设置为10和11）</li>
</ul>
<p><code>LORBIT=10</code>时，态密度投影的轨道只包含s&#x2F;p&#x2F;d&#x2F;f轨道；<code>LORBIT=11</code>时，态密度除了输出总的轨道信息，还会投影到分轨道上，如<code>px</code>、<code>py</code>、<code>pz</code>等。</p>
<p>总的来说，计算前先确定<code>LORBIT</code>的数值来决定是否需要分轨道的数据，然后再确定<code>ISPIN</code>、<code>EMIN</code>、<code>EMAX</code>、<code>NEDOS</code>的数值来考虑作图需求。</p>
<mark class="hl-label blue">磁性体系必须打开`ISPIN`</mark>

<h5 id="KPOINTS文件"><a href="#KPOINTS文件" class="headerlink" title="KPOINTS文件"></a>KPOINTS文件</h5><p><code>MPNonSCFSet</code>模块默认生成的<code>KPOINTS</code>文件中的K点写法是<code>line-mode</code>，该方法一般用于能带结构的计算。因此在态密度计算中，我们可以写常规的K点进行覆盖：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPNonSCFSet</span><br><span class="line"></span><br><span class="line">kpoints = &#123;</span><br><span class="line">    <span class="string">&quot;length&quot;</span>:<span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nonscf_dos = MPNonSCFSet.from_prev_calc(</span><br><span class="line">    prev_calc_dir=<span class="string">&#x27;./static&#x27;</span>, </span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>,</span><br><span class="line">    user_kpoints_settings=kpoints,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">nonscf_dos.write_input(<span class="string">&#x27;./dos&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DOS_calc is ready!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>态密度计算的K网格要足够大才算的准，在普通结构优化的K点个数2倍以上，大体系算不动可适量降低。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>态密度计算就介绍到这，各位多多练习~~~~</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.6  计算小白硬学VASP —— 材料性质计算—&gt;态密度分析(1)</title>
    <url>/2024/06/13/Learn-VASP-from-pymatgen-6/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何使用<code>pymatgen</code>对态密度结果进行分析。</p>
<h4 id="案例1：Si态密度"><a href="#案例1：Si态密度" class="headerlink" title="案例1：Si态密度"></a>案例1：Si态密度</h4><p>先从一个简单的案例入手，了解下<code>pymatgen</code>怎么从<code>VASP</code>的计算结构中分析态密度数据。</p>
<p>下面是生成从结构优化到态密度计算的完整代码：</p>
<mark class="hl-label blue">参考代码</mark>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet, MPStaticSet, MPNonSCFSet</span><br><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&quot;your key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">  struct = mpr.get_structure_by_material_id(<span class="string">&quot;mp-149&quot;</span>)</span><br><span class="line">  struct.to(filename=<span class="string">&quot;./SiPOSCAR&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结构优化</span></span><br><span class="line">relax_kpoints = &#123;<span class="string">&quot;length&quot;</span>:<span class="number">30</span>&#125;</span><br><span class="line">relax_incar = &#123;</span><br><span class="line">    <span class="string">&quot;EDIFFG&quot;</span>:-<span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&quot;ISMEAR&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;ENCUT&quot;</span>:<span class="number">300</span>,    </span><br><span class="line">&#125;</span><br><span class="line">relax = MPRelaxSet(</span><br><span class="line">    struct, </span><br><span class="line">    user_kpoints_settings=relax_kpoints,</span><br><span class="line">    user_incar_settings=relax_incar,</span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">relax.write_input(<span class="string">&#x27;./relax&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态自洽计算(等relax算完再运行)</span></span><br><span class="line">static_kpoints = &#123;<span class="string">&quot;length&quot;</span>:<span class="number">60</span>&#125;</span><br><span class="line">static = MPStaticSet.from_prev_calc(</span><br><span class="line">    prev_calc_dir=<span class="string">&#x27;./relax&#x27;</span>, </span><br><span class="line">    user_kpoints_settings=static_kpoints,</span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">static.write_input(<span class="string">&#x27;./static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DOS计算(等静态自洽算完再运行)</span></span><br><span class="line">dos_incar = &#123;</span><br><span class="line">    <span class="string">&quot;EMIN&quot;</span>:-<span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;EMAX&quot;</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;NEDOS&quot;</span>:<span class="number">2001</span>,</span><br><span class="line">    <span class="string">&quot;LORBIT&quot;</span>:<span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">dos_kpoints = &#123;<span class="string">&quot;length&quot;</span>:<span class="number">60</span>&#125;</span><br><span class="line">DOS = MPNonSCFSet.from_prev_calc(</span><br><span class="line">    prev_calc_dir=<span class="string">&#x27;./static&#x27;</span>, </span><br><span class="line">    user_incar_settings=dos_incar,</span><br><span class="line">    user_kpoints_settings=dos_kpoints,</span><br><span class="line">    user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">DOS.write_input(<span class="string">&#x27;./dos&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>分析态密度的结果需要读<code>vasprun.xml</code>文件，这里我们需要导入<code>Vasprun</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读态密度算完的vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取Complete dos对象</span></span><br><span class="line">dos = vasprun.complete_dos</span><br></pre></td></tr></table></figure>

<p>导入<code>Vasprun</code>模块后，通过该模块<code>complete_dos</code>方法获取完整的态密度对象，<code>dos</code>里面包含着所有的态密度信息以及对应的能量范围。<strong>但是有一点需要注意，通过<code>pymatgen</code>获取的<code>dos</code>里面，费米能级是没有拟合到0的，然而为了便于分析，一般的操作是把费米能级拟合到0，因此我们还需要手动把<code>Energy</code>范围拟合一下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读态密度算完的vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取Complete dos对象</span></span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line"><span class="comment"># 获取费米能级</span></span><br><span class="line">fermi = dos.efermi</span><br><span class="line"><span class="comment"># 整体能量平移至费米能级为0</span></span><br><span class="line">energy = dos.energy - fermi</span><br></pre></td></tr></table></figure>

<h5 id="体系总态密度"><a href="#体系总态密度" class="headerlink" title="体系总态密度"></a>体系总态密度</h5><p>体系总态密度，即TDOS；代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 体系总态密度</span></span><br><span class="line"><span class="comment"># 获取全部的Density</span></span><br><span class="line">total_densities = dos.densities</span><br><span class="line"><span class="comment"># 将费米能级拟合至0之后的Energy与Density重新组合</span></span><br><span class="line">total_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Density&#x27;</span>: total_densities[Spin.up]&#125;)</span><br><span class="line"><span class="comment"># 输出TDOS</span></span><br><span class="line"><span class="built_in">print</span>(total_dos)</span><br><span class="line"><span class="comment"># 保存为csv文件</span></span><br><span class="line">total_dos.to_csv(<span class="string">&#x27;total_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>



<p>上述代码第14行<code>&#39;Density&#39;: total_densities[Spin.up]</code>只指定了自旋向上的态。是因为体系无磁性，<code>MPNonSCFSet</code>读<code>static</code>文件夹自动生成输入是把<code>ISPIN</code>关掉了，所以这里的<code>Spin.up</code>的数值就是总的<code>Density</code>的数值。同理，对于有磁性的体系，这一行代码可以写成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Spin_Up&#x27;</span>: total_densities[Spin.up], <span class="string">&#x27;Spin_Dn&#x27;</span>: total_densities[Spin.down]&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="元素总态密度"><a href="#元素总态密度" class="headerlink" title="元素总态密度"></a>元素总态密度</h5><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素总态密度</span></span><br><span class="line"><span class="comment"># dos信息按照元素分类</span></span><br><span class="line">element_dos = dos.get_element_dos()</span><br><span class="line"><span class="comment"># 提取指定元素的Density</span></span><br><span class="line">Si_densities = element_dos[Element(<span class="string">&#x27;Si&#x27;</span>)].densities</span><br><span class="line"><span class="comment"># 组合</span></span><br><span class="line">Si_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Density&#x27;</span>: Si_densities[Spin.up]&#125;)</span><br><span class="line"><span class="built_in">print</span>(Si_dos)</span><br><span class="line"><span class="comment"># 保存输出</span></span><br><span class="line">Si_dos.to_csv(<span class="string">&#x27;Si_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是第11行，12行，这里如果我们打印出11行的内容可以得到：</p>
<blockquote>
<p><em>{Element Si: &lt;pymatgen.electronic_structure.dos.Dos object at 0x000001918E2EE6D0&gt;}</em></p>
</blockquote>
<p>说明<code>get_element_dos()</code>的输出实际是一个字典，对应着元素的种类已经对应的态密度信息对象。因此为了得到具体的态密度值，就需要第12行代码的内容来进行提取，打印第12行的内容，可以得到以下结果：</p>
<blockquote>
<p><em>{&lt;Spin.up: 1&gt;: array([0.    , 0.    , 0.    , …, 0.5654, 0.3542, 0.145 ])}</em></p>
</blockquote>
<p>此时的数据还是字典形式，提取<code>Spin.up</code>的值就是下一步中的<code>Si_densities[Spin.up]</code>；同理，对于磁性体系，<code>spin.down</code>值的提取也类似。</p>
<h5 id="体系分态密度"><a href="#体系分态密度" class="headerlink" title="体系分态密度"></a>体系分态密度</h5><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 体系分态密度</span></span><br><span class="line">spd_dos = dos.get_spd_dos()</span><br><span class="line"><span class="comment"># 体系s轨道Density</span></span><br><span class="line">total_s = spd_dos[OrbitalType.s].densities</span><br><span class="line"><span class="comment"># 体系s轨道Density</span></span><br><span class="line">total_p = spd_dos[OrbitalType.p].densities</span><br><span class="line"><span class="comment"># 重组</span></span><br><span class="line">total_sp_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Total_s&#x27;</span>: total_s[Spin.up], <span class="string">&#x27;Total_p&#x27;</span>: total_p[Spin.up]&#125;)</span><br><span class="line"><span class="built_in">print</span>(total_sp_dos)</span><br><span class="line"><span class="comment"># 保存输出</span></span><br><span class="line">total_sp_dos.to_csv(<span class="string">&#x27;total_sp_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="元素分态密度"><a href="#元素分态密度" class="headerlink" title="元素分态密度"></a>元素分态密度</h5><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素分态密度</span></span><br><span class="line"><span class="comment"># 获取元素所有轨道</span></span><br><span class="line">Si_spd_dos = dos.get_element_spd_dos(<span class="string">&#x27;Si&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取s轨道</span></span><br><span class="line">Si_s = Si_spd_dos[OrbitalType.s].densities</span><br><span class="line"><span class="comment"># 提取p轨道</span></span><br><span class="line">Si_p = Si_spd_dos[OrbitalType.p].densities</span><br><span class="line"><span class="comment"># 重组</span></span><br><span class="line">Si_sp_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Si_s&#x27;</span>: Si_s[Spin.up], <span class="string">&#x27;Si_p&#x27;</span>: Si_p[Spin.up]&#125;)</span><br><span class="line"><span class="built_in">print</span>(Si_sp_dos)</span><br><span class="line"><span class="comment"># 保存输出</span></span><br><span class="line">Si_sp_dos.to_csv(<span class="string">&#x27;Si_sp_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="原子总态密度"><a href="#原子总态密度" class="headerlink" title="原子总态密度"></a>原子总态密度</h5><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素位点总态密度</span></span><br><span class="line"><span class="comment"># 提取指定原子Density，structure[0]表示1号原子</span></span><br><span class="line">site_densities = dos.get_site_dos(dos.structure[<span class="number">0</span>]).densities</span><br><span class="line"><span class="comment"># 重组</span></span><br><span class="line">site_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;Density&#x27;</span>: site_densities[Spin.up]&#125;)</span><br><span class="line"><span class="built_in">print</span>(site_dos)</span><br><span class="line"><span class="comment"># 保存输出</span></span><br><span class="line">site_dos.to_csv(<span class="string">&#x27;site_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="原子分态密度"><a href="#原子分态密度" class="headerlink" title="原子分态密度"></a>原子分态密度</h5><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.periodic_table <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">dos = vasprun.complete_dos</span><br><span class="line">energy = dos.energies - dos.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素位点分态密度</span></span><br><span class="line"><span class="comment"># 获取1号原子所有轨道态密度</span></span><br><span class="line">site_spd_dos = dos.get_site_spd_dos(dos.structure[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 提取s轨道</span></span><br><span class="line">site_s_densities = site_spd_dos[OrbitalType.s].densities</span><br><span class="line"><span class="comment"># 提取p轨道</span></span><br><span class="line">site_p_densities = site_spd_dos[OrbitalType.p].densities</span><br><span class="line"><span class="comment"># 重组</span></span><br><span class="line">site_sp_dos = pd.DataFrame(&#123;<span class="string">&#x27;Energy&#x27;</span>: energy, <span class="string">&#x27;s&#x27;</span>: site_s_densities[Spin.up], <span class="string">&#x27;p&#x27;</span>: site_p_densities[Spin.up]&#125;)</span><br><span class="line"><span class="built_in">print</span>(site_sp_dos)</span><br><span class="line"><span class="comment"># 保存输出</span></span><br><span class="line">site_sp_dos.to_csv(<span class="string">&#x27;site_sp_dos.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>上述介绍了从体系整体，元素种类到具体单个原子的总态密度和分态密度的处理方法，每种方法的使用都比较类似，跟着老司机的代码实操一遍应该问题不大。总的来说，就是根据不同的需求，使用不同的方法：</p>
<ul>
<li><p><strong>体系总态密度</strong>：使用 <code>dos.densities</code></p>
</li>
<li><p><strong>元素总态密度</strong>：使用 <code>dos.get_element_dos()</code></p>
</li>
<li><p><strong>体系分态密度</strong>：使用 <code>dos.get_spd_dos()</code></p>
</li>
<li><p><strong>元素分态密度</strong>：使用 <code>dos.get_element_spd_dos()</code></p>
</li>
<li><p><strong>原子总态密度</strong>：使用 <code>dos.get_site_dos()</code></p>
</li>
<li><p><strong>原子分态密度</strong>：使用 <code>dos.get_site_spd_dos()</code></p>
</li>
</ul>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.7  计算小白硬学VASP —— 材料性质计算—&gt;态密度分析（2）</title>
    <url>/2024/06/17/Learn-VASP-from-pymatgen-7/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章主要介绍态密度画图的两种的方法。</p>
<h5 id="常规方法——Matplotlib"><a href="#常规方法——Matplotlib" class="headerlink" title="常规方法——Matplotlib"></a>常规方法——Matplotlib</h5><p>上一章介绍了如何分析dos计算的结果，并根据需求把态密度轨道数据保存为csv文件。在此基础上常规绘图方法就是采用<code>matpltolib</code>库的<code>pyplot</code>模块。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件</span></span><br><span class="line"><span class="comment"># 以Si的分轨道为例</span></span><br><span class="line">csv_file = <span class="string">&#x27;./Si_sp_dos.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取csv文件</span></span><br><span class="line">df = pd.read_csv(csv_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出需要的数据</span></span><br><span class="line">energy = df[<span class="string">&#x27;Energy&#x27;</span>]</span><br><span class="line">s_orbital = df[<span class="string">&#x27;Si_s&#x27;</span>]</span><br><span class="line">p_orbital = df[<span class="string">&#x27;Si_p&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.plot(energy, s_orbital, label=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(energy, p_orbital, label=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Energy (eV)&#x27;</span>)</span><br><span class="line">plt.xlim(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Density of States (states/eV)&#x27;</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/17/Learn-VASP-from-pymatgen-7/image-20240618092517244.png" alt="image-20240618092517244"></p>
<p>这里可以看到态密度画出来，毛刺非常多，原因可以分为两个部分：</p>
<p>- 在设置<code>INCAR</code>时，NEDOS的数量较大或<code>EMIN</code>,<code>ENMAX</code>的区间过小，导致取点非常密集；</p>
<p>- 主要原因还是在<code>INCAR</code>中，<code>ISMEAR = -5</code>时，<code>sigma</code>为0，费米狄拉克分布，不会有展宽（见下左图），这就导致相邻的态是直接过渡的，没有考虑平滑处理，所以画出来的dos图普遍毛刺比较多。这也是为什么也有很多人在算态密度的时候选择<code>ISMEAR = 0</code>，出图放文章里面会好看一点。</p>
<p><img src="/2024/06/17/Learn-VASP-from-pymatgen-7/dirac.png" alt="dirac"></p>
<h5 id="手动平滑处理——scipy-ndimage-gaussian-filter1d"><a href="#手动平滑处理——scipy-ndimage-gaussian-filter1d" class="headerlink" title="手动平滑处理——scipy.ndimage.gaussian_filter1d"></a>手动平滑处理——scipy.ndimage.gaussian_filter1d</h5><p>当然，<code>python</code>有许许多多其他的库可以用来平滑处理，这样就避免了我们重新设置参数进行计算。这里采用<code>scipy.ndimage.gaussian_filter1d</code>模块进行平滑处理，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_filter1d</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件</span></span><br><span class="line"><span class="comment"># 以Si的分轨道为例</span></span><br><span class="line">csv_file = <span class="string">&#x27;./Si_sp_dos.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取csv文件</span></span><br><span class="line">df = pd.read_csv(csv_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出需要的数据</span></span><br><span class="line">energy = df[<span class="string">&#x27;Energy&#x27;</span>]</span><br><span class="line"><span class="comment"># 平滑处理</span></span><br><span class="line">s_orbital = gaussian_filter1d(df[<span class="string">&#x27;Si_s&#x27;</span>], sigma=<span class="number">3</span>)</span><br><span class="line">p_orbital = gaussian_filter1d(df[<span class="string">&#x27;Si_p&#x27;</span>], sigma=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.plot(energy, s_orbital, label=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(energy, p_orbital, label=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Energy (eV)&#x27;</span>)</span><br><span class="line">plt.xlim(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Density of States (states/eV)&#x27;</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/17/Learn-VASP-from-pymatgen-7/image-20240618093500328.png" alt="image-20240618093500328"></p>
<p>也可以得到相对客观的结果。这里平滑度由<code>sigma</code>参数控制，根据需求需自行调整。</p>
<h5 id="pymatgen自带模块——DosPlotter"><a href="#pymatgen自带模块——DosPlotter" class="headerlink" title="pymatgen自带模块——DosPlotter"></a>pymatgen自带模块——DosPlotter</h5><p>DosPlotter是专门用于绘制态密度图的类，可以直接从VASP计算的输出文件中读取数据并绘制，并且绘图结果默认把费米能级平移至0eV，方便比较。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> DosPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> OrbitalType, Spin</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 vasprun.xml 文件</span></span><br><span class="line">dos_vasprun = Vasprun(<span class="string">&#x27;./dos/vasprun.xml&#x27;</span>)</span><br><span class="line">complete_dos = dos_vasprun.complete_dos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个字典，用于存储 PDOS</span></span><br><span class="line">pdos_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个字典，用于存储元素和对应的轨道列表</span></span><br><span class="line">element_orbitals = &#123;</span><br><span class="line">    <span class="string">&#x27;Si&#x27;</span>: [OrbitalType.s, OrbitalType.p],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历元素和对应的轨道列表</span></span><br><span class="line"><span class="keyword">for</span> element, orbitals <span class="keyword">in</span> element_orbitals.items():  </span><br><span class="line">    <span class="comment"># 创建一个空字典储存当前元素的所有轨道列表</span></span><br><span class="line">    pdos_dict[element] = &#123;&#125;         </span><br><span class="line">    <span class="comment"># 遍历当前元素的轨道列表</span></span><br><span class="line">    <span class="keyword">for</span> orbital <span class="keyword">in</span> orbitals:        </span><br><span class="line">    <span class="comment"># 对于当前元素的当前轨道，将 PDOS 存储在 pdos_dict 字典中   </span></span><br><span class="line">        pdos_dict[element][<span class="built_in">str</span>(orbital)] = complete_dos.get_element_spd_dos(element)[orbital]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 DosPlotter 对象</span></span><br><span class="line">dos_plotter = DosPlotter()</span><br><span class="line"><span class="comment"># 添加 PDOS</span></span><br><span class="line"><span class="keyword">for</span> element, orbitals <span class="keyword">in</span> pdos_dict.items():</span><br><span class="line">    <span class="comment"># 此行遍历当前元素的 PDOS 字典，其中每个键是轨道的名称，对应的值是该轨道的 PDOS</span></span><br><span class="line">    <span class="keyword">for</span> orbital, pdos <span class="keyword">in</span> orbitals.items():      </span><br><span class="line">        pdos_data = dos_plotter.add_dos(<span class="string">f&#x27;<span class="subst">&#123;element&#125;</span>(<span class="subst">&#123;orbital&#125;</span>)&#x27;</span>,pdos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 PDOS</span></span><br><span class="line">dos_plotter.get_plot(xlim=(-<span class="number">5</span>,<span class="number">5</span>),ylim=(<span class="number">0</span>,<span class="number">1.5</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;Si pdos&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/17/Learn-VASP-from-pymatgen-7/image-20240618092704087.png" alt="image-20240618092704087"></p>
<p>直接使用<code>DosPlotter</code>也可以绘制出类似的结果，然而<code>DosPlotter</code>绘制的结果会自动标出费米能级参考线，即<code>x=0</code>参考线，同时自身还提供了平滑曲线的功能，<code>DosPlotter</code>可以接受的参数有：</p>
<p>- <code>zero_at_efermi</code>：布尔值，是否将费米能级作为零点，默认值为<code>True</code>；</p>
<p>- <code>stack</code>：布尔值，是否绘制成面积图，默认值为<code>False</code>；</p>
<p>- <code>sigma</code>：浮点数，平滑曲线的标准差，值越大，曲线约平滑。</p>
<p>这里重新修改下，增加<code>sigma</code>参数使得曲线平滑一点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 DosPlotter 对象</span></span><br><span class="line">dos_plotter = DosPlotter(sigma=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>再次运行代码：</p>
<p><img src="/2024/06/17/Learn-VASP-from-pymatgen-7/image-20240618092835225.png" alt="image-20240618092835225"></p>
<p>曲线平滑了非常多，但是具体使用过程中，<code>sigma</code>参数的选择还是很重要的，如果过于平滑，可能会失去重要的性质，所以实际使用时，需要根据实际情况进行调整。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>既然第二种方法可以直接画，那为啥还要费老鼻子劲输出csv文件呢，是否多此一举。</p>
<p>实际上，上一步输出csv文件跟这一步画图的操作并不冲突，输出csv文件是为了保存绘图源数据，<code>vasprun.xml</code>文件虽然包含了计算的所有数据，但是动辄几百兆的大小也不太适合作为长期保存的文件。</p>
<p>推荐的做法是，无论怎么画图，都最好导出相关的数据保存为csv文件。小规模的计算结果的处理，两者差异不大；但是对于高通量来说，如果需要批量处理画图，直接读取csv文件绘图要快得多。例如上面两种方法，直接读csv绘图运行时间只要<code>0.1s</code>；第二种方法读<code>vasprun.xml</code>文件绘图，运行时间可能需要<code>4.3s</code>,这个差距就比较明显了。</p>
<p>话虽如此，但是在高通量计算过程中，主要是的时间消耗还是在计算上，绘图上面的时间差在<code>VASP</code>计算的时间上可以忽略不计~~~~~~</p>
<p>简而言之就是，记得保存数据，画图爱用啥用啥，都一样，无非就是代码不一样，<code>DosPlotter</code>预设了一些格式，而直接用<code>matplotlib</code>就自行设置一下格式（字体、字号、排版）就好了。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.8  计算小白硬学VASP —— 材料性质计算—&gt;能带计算</title>
    <url>/2024/06/18/Learn-VASP-from-pymatgen-8/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何计算能带结构，VASP计算流程代码如下：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">下载结构</button><button type="button" class="tab">结构优化</button><button type="button" class="tab">自洽计算</button><button type="button" class="tab">能带计算</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mp_api.client <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">api_key = <span class="string">&#x27;your key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MPRester(api_key) <span class="keyword">as</span> mpr:</span><br><span class="line">    <span class="comment"># 获取结构</span></span><br><span class="line">    structure = mpr.get_structure_by_material_id(<span class="string">&#x27;mp-924129&#x27;</span>)</span><br><span class="line">    <span class="comment"># 转化成原胞</span></span><br><span class="line">    primtive_structure = structure.get_primitive_structure()</span><br><span class="line">    <span class="comment"># 保存结构</span></span><br><span class="line">    primtive_structure.to(filename=<span class="string">&#x27;ZrNiSn_primitive.cif&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPRelaxSet</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.inputs <span class="keyword">import</span> Kpoints</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构路径</span></span><br><span class="line">primtive_cell = <span class="string">&#x27;./ZrNiSn_primitive.cif&#x27;</span></span><br><span class="line"><span class="comment">#自定义INCAR</span></span><br><span class="line">incar = &#123;</span><br><span class="line">    <span class="string">&quot;ENCUT&quot;</span>:<span class="number">400</span>,</span><br><span class="line">    <span class="string">&quot;EDIFF&quot;</span>:<span class="number">1E-4</span>,</span><br><span class="line">    <span class="string">&quot;EDIFG&quot;</span>:-<span class="number">0.05</span>,</span><br><span class="line">    <span class="string">&quot;ISPIN&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;LORBIT&quot;</span>:<span class="number">12</span>, </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">struct = Structure.from_file(primtive_cell)</span><br><span class="line"><span class="comment"># 生成relax输入</span></span><br><span class="line">primtive_relax = MPRelaxSet(struct, user_incar_settings=incar, user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">primtive_relax.write_input(<span class="string">&#x27;./ZrNiSn_primitive/relax&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPStaticSet</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构优化文件路径</span></span><br><span class="line">relax_dir = <span class="string">&#x27;./ZrNiSn_primitive/relax&#x27;</span></span><br><span class="line"><span class="comment"># 自定义INCAR</span></span><br><span class="line">static_incar = &#123;</span><br><span class="line">    <span class="string">&quot;EDIFF&quot;</span>:<span class="number">1E-6</span>,</span><br><span class="line">    <span class="string">&quot;ISMEAR&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;LORBIT&quot;</span>:<span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 生成自洽计算输入</span></span><br><span class="line">primtive_static = MPStaticSet.from_prev_calc(prev_calc_dir=relax_dir,user_incar_settings=static_incar, user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">prim_static.write_input(<span class="string">&#x27;./ZrNiSn_primitive/static&#x27;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.sets <span class="keyword">import</span> MPNonSCFSet</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.bandstructure <span class="keyword">import</span> HighSymmKpath</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.inputs <span class="keyword">import</span> Kpoints</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自洽计算路径</span></span><br><span class="line">static_dir = <span class="string">&#x27;./ZrNiSn_primitive/static&#x27;</span></span><br><span class="line"><span class="comment"># 读取结构</span></span><br><span class="line">structure = Structure.from_file(os.path.join(static_dir, <span class="string">&#x27;POSCAR&#x27;</span>))</span><br><span class="line"><span class="comment"># 生成高对称路径</span></span><br><span class="line">kpath = HighSymmKpath(structure=structure,path_type=<span class="string">&#x27;hinuma&#x27;</span>)</span><br><span class="line"><span class="comment"># 自动根据高对称路径生成K点</span></span><br><span class="line">kpoints = Kpoints.automatic_linemode(divisions=<span class="number">10</span>,ibz=kpath)</span><br><span class="line"><span class="comment"># 自定义INCAR</span></span><br><span class="line">band_incar = &#123;</span><br><span class="line">    <span class="string">&quot;EDIFF&quot;</span>:<span class="number">1E-6</span>,</span><br><span class="line">    <span class="string">&quot;ISMEAR&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;LORBIT&quot;</span>:<span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;NBANDS&quot;</span>:<span class="number">64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 生成band输入</span></span><br><span class="line">band = MPNonSCFSet.from_prev_calc(prev_calc_dir=static_dir,user_incar_settings=band_incar,user_kpoints_settings=kpoints,user_potcar_functional=<span class="string">&#x27;PBE_54&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">band.write_input(<span class="string">&#x27;./ZrNiSn_primitive/band&#x27;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>INCAR中有几点设置需要注意：</p>
<ul>
<li><code>ISPIN</code>开关需要根据自己的体系来决定是否考虑自旋；</li>
<li><code>LORBIT</code>建议全程设置为12，方便后面分析轨道投影能带&#x2F;态密度。</li>
</ul>
<p>能带计算中这里我们采用<code>HighSymmKpath</code>方法自动针对结构生成高对称路径，需要注意的是，这里的结构必须是<code>primtive_cell</code>。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap.9  计算小白硬学VASP —— 材料性质计算—&gt;能带分析</title>
    <url>/2024/06/27/Learn-VASP-from-pymatgen-9/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>本章介绍如何分析能带计算结果。</p>
<h3 id="导出gap-CBM-VBM信息"><a href="#导出gap-CBM-VBM信息" class="headerlink" title="导出gap&#x2F;CBM&#x2F;VBM信息"></a>导出gap&#x2F;CBM&#x2F;VBM信息</h3><p>能带计算完后，直接读取<code>vasprun.xml</code>文件，可以最快的得到禁带宽度、CBM&#x2F;VBM的数值，以及半导体种类（直接带隙&#x2F;间接带隙）。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>)</span><br><span class="line"><span class="comment"># 获取gap/vbm/cbm</span></span><br><span class="line">bandgap_dict = vasprun.get_band_structure().get_band_gap()</span><br><span class="line">vbm = vasprun.get_band_structure().get_vbm()[<span class="string">&quot;energy&quot;</span>]</span><br><span class="line">cbm = vasprun.get_band_structure().get_cbm()[<span class="string">&quot;energy&quot;</span>]</span><br><span class="line"><span class="comment"># 添加到数据框中</span></span><br><span class="line">bandgap = pd.DataFrame([bandgap_dict])</span><br><span class="line">bandgap[<span class="string">&quot;VBM&quot;</span>] = vbm</span><br><span class="line">bandgap[<span class="string">&quot;CBM&quot;</span>] = cbm</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bandgap)</span><br></pre></td></tr></table></figure>

<p>运行代码可输出如下表格的信息：</p>
<table>
<thead>
<tr>
<th align="center">direct</th>
<th>energy</th>
<th>transition</th>
<th>VBM</th>
<th align="center">CBM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">False</td>
<td>0.5059</td>
<td>GAMMA-X</td>
<td>8.489</td>
<td align="center">8.9949</td>
</tr>
</tbody></table>
<p>从左至右分别为：是否为直接带隙、禁带宽度、VBM&#x2F;CBM指向、VBM能量、CBM能量。</p>
<p>还可以用<code>BandStructure</code>类同样可以得到类似信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.bandstructure <span class="keyword">import</span> BandStructure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line">band = BandStructure.from_dict(vasprun.get_band_structure().as_dict())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(band.get_band_gap())</span><br></pre></td></tr></table></figure>

<h3 id="导出能量本征值"><a href="#导出能量本征值" class="headerlink" title="导出能量本征值"></a>导出能量本征值</h3><p>还可以直接得到每条能带的能量本征值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.bandstructure <span class="keyword">import</span> BandStructure</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> Spin, Orbital</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line">band = BandStructure.from_dict(vasprun.get_band_structure().as_dict())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出自旋向上能量本征值</span></span><br><span class="line">eigenvalues = pd.DataFrame(band.bands[Spin.up])</span><br><span class="line"><span class="built_in">print</span>(eigenvalues)</span><br><span class="line">eigenvalues.to_csv(<span class="string">&quot;eigenvalues.csv&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>得到的数据格式索引符合<code>[band_index, kpoint_index]</code>。</p>
<h3 id="导出完整的能带数据"><a href="#导出完整的能带数据" class="headerlink" title="导出完整的能带数据"></a>导出完整的能带数据</h3><p>除了一些特殊的需求，最重要的还是想要得到能带图，那么下面提供的代码就可以用来得到源数据用于绘图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.io.vasp <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.core <span class="keyword">import</span> Spin</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 vasprun.xml 文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取能带结构</span></span><br><span class="line">band_structure = vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 获取 k 点数据</span></span><br><span class="line">kpoints = band_structure.kpoints</span><br><span class="line"><span class="comment"># 选择自旋通道</span></span><br><span class="line">selected_spin = Spin.up  <span class="comment"># 或者 Spin.down，根据你需要的自旋通道选择</span></span><br><span class="line"><span class="comment"># 获取指定自旋通道的能带数据</span></span><br><span class="line">energies = band_structure.bands[selected_spin]</span><br><span class="line"><span class="comment"># 获取费米能级</span></span><br><span class="line">fermi_level = band_structure.efermi</span><br><span class="line"><span class="comment"># 准备存储数据</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个能带和 k 点，提取能量信息</span></span><br><span class="line"><span class="keyword">for</span> band_index, band <span class="keyword">in</span> <span class="built_in">enumerate</span>(energies):</span><br><span class="line">    <span class="keyword">for</span> kpoint_index, energy <span class="keyword">in</span> <span class="built_in">enumerate</span>(band):</span><br><span class="line">        <span class="keyword">if</span> kpoint_index &lt; <span class="built_in">len</span>(kpoints):  <span class="comment"># 防止索引超出范围</span></span><br><span class="line">            kpoint_coords = kpoints[kpoint_index].frac_coords  <span class="comment"># 获取 k 点的坐标</span></span><br><span class="line">            kpoint_label = kpoints[kpoint_index].label  <span class="comment"># 获取 k 点的标签（如有）</span></span><br><span class="line">            kpoint_distance = band_structure.distance[kpoint_index]  <span class="comment"># k 点在路径上的距离</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 k 点有标签，使用标签；否则使用坐标</span></span><br><span class="line">            <span class="keyword">if</span> kpoint_label:</span><br><span class="line">                kpoint_info = kpoint_label</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                kpoint_info = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, kpoint_coords))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将数据添加到列表中</span></span><br><span class="line">            data.append(&#123;</span><br><span class="line">                <span class="string">&quot;spin&quot;</span>: selected_spin.name,</span><br><span class="line">                <span class="string">&quot;kpoint&quot;</span>: kpoint_info,</span><br><span class="line">                <span class="string">&quot;kpoint distance&quot;</span>: kpoint_distance,</span><br><span class="line">                <span class="string">&quot;band index&quot;</span>: band_index,</span><br><span class="line">                <span class="string">&quot;energy (eV)&quot;</span>: energy - fermi_level  <span class="comment"># 能量相对费米能级</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 DataFrame</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 保存为 CSV 文件</span></span><br><span class="line">csv_filename = <span class="string">f&quot;band_structure_data_spin_<span class="subst">&#123;selected_spin.name&#125;</span>.csv&quot;</span></span><br><span class="line">df.to_csv(csv_filename, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码可以得到如下格式的csv文件：</p>
<table>
<thead>
<tr>
<th align="center">spin</th>
<th align="center">kpoints</th>
<th align="center">kpoints distance</th>
<th align="center">band index</th>
<th align="center">energy(eV)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">up</td>
<td align="center">GAMMA</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-63.5333</td>
</tr>
<tr>
<td align="center">up</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">up</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>从左至右分别为：自旋方向，K点坐标，K点距离，第几条能带，能量本征值。</p>
<p>绘图时采用第三列为x轴，第五列为y轴，最后对应的横坐标位置标注对应的高对称点即可。</p>
<h3 id="matplotlib库绘图"><a href="#matplotlib库绘图" class="headerlink" title="matplotlib库绘图"></a>matplotlib库绘图</h3><p>根据上面得到的<code>band_structure_data_spin_up.csv</code>文件，我们可以用<code>matplotlib</code>库进行绘图，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CSV 文件</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;band_structure_data_spin_up.csv&quot;</span>)  <span class="comment"># 替换为你的 CSV 文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取唯一的能带索引</span></span><br><span class="line">band_indices = df[<span class="string">&#x27;band index&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个能带，绘制对应的能带图</span></span><br><span class="line"><span class="keyword">for</span> band_index <span class="keyword">in</span> band_indices:</span><br><span class="line">    band_data = df[df[<span class="string">&#x27;band index&#x27;</span>] == band_index]</span><br><span class="line">    plt.plot(band_data[<span class="string">&#x27;k-point distance&#x27;</span>], band_data[<span class="string">&#x27;energy (eV)&#x27;</span>], color=<span class="string">&#x27;blue&#x27;</span>)  <span class="comment"># 使用相同的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加图形标签和标题</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Energy (eV)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Band Structure&#x27;</span>)</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>,)  <span class="comment"># 绘制费米能级线</span></span><br><span class="line">plt.ylim(-<span class="number">10.5</span>,<span class="number">10.5</span>)</span><br><span class="line">plt.xlim(df[<span class="string">&#x27;k-point distance&#x27;</span>].<span class="built_in">min</span>(), df[<span class="string">&#x27;k-point distance&#x27;</span>].<span class="built_in">max</span>())</span><br><span class="line">plt.xticks([])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加高对称点</span></span><br><span class="line">high_symmetry_points = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;GAMMA&quot;</span>,</span><br><span class="line">    <span class="number">1.0245</span>: <span class="string">&quot;X&quot;</span>,</span><br><span class="line">    <span class="number">1.387</span>: <span class="string">&quot;U|K&quot;</span>,</span><br><span class="line">    <span class="number">2.473</span>: <span class="string">&quot;GAMMA&quot;</span>,</span><br><span class="line">    <span class="number">3.36</span>: <span class="string">&quot;L&quot;</span>,</span><br><span class="line">    <span class="number">4.085</span>: <span class="string">&quot;W&quot;</span>,</span><br><span class="line">    <span class="number">4.597</span>: <span class="string">&quot;X&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整文本与坐标轴的间隙</span></span><br><span class="line">gap = -<span class="number">0.5</span>  <span class="comment"># 你可以根据需要调整这个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> position, point <span class="keyword">in</span> high_symmetry_points.items():</span><br><span class="line">    plt.axvline(x=position, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    plt.text(position, plt.ylim()[<span class="number">0</span>] + gap, point, verticalalignment=<span class="string">&#x27;top&#x27;</span>, horizontalalignment=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/27/Learn-VASP-from-pymatgen-9/image-20240627175623136.png" alt="image-20240627175623136"></p>
<p>该方法相对麻烦，不够自动化，还需要我们手动去提供高对称点参考线的字典，因此这里推荐另一种方法。</p>
<h3 id="BSPlotter方法绘图"><a href="#BSPlotter方法绘图" class="headerlink" title="BSPlotter方法绘图"></a>BSPlotter方法绘图</h3><p><code>pymatgen</code>有可以直接处理能带计算<code>vasprun.xml</code>文件的模块——<code>pymatgen.electronic_structure.plotter.BSPlotter</code>，直接绘制能带结果图。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 vasprun.xml 文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>, parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 提取带结构</span></span><br><span class="line">band = vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 创建带结构绘图对象</span></span><br><span class="line">bs_plotter = BSPlotter(band)</span><br><span class="line"><span class="comment"># 绘制带结构</span></span><br><span class="line">bs_plotter.get_plot()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/27/Learn-VASP-from-pymatgen-9/image-20240628110447068.png" alt="image-20240628110447068"></p>
<p><code>BSPlotter</code>使用起来非常方便，只需要读取相应的<code>vasprun.xml</code>文件即可，然而也有不足的地方，默认输出的图片格式不太美观，字体过大。这里我们可以在<code>get_plot()</code>方法之后，修改<code>matplotlib</code>的属性进行覆盖即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 vasprun.xml 文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">&quot;../ZrNiSn_primitive/band/vasprun.xml&quot;</span>, parse_projected_eigen=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 提取带结构</span></span><br><span class="line">band = vasprun.get_band_structure(line_mode=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 创建带结构绘图对象</span></span><br><span class="line">bs_plotter = BSPlotter(band)</span><br><span class="line"><span class="comment"># 生成带结构图，获取 Axes 对象</span></span><br><span class="line">ax = bs_plotter.get_plot(ylim=[-<span class="number">2</span>, <span class="number">4</span>], smooth=<span class="literal">True</span>, vbm_cbm_marker=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖字体大小</span></span><br><span class="line">fontsize = <span class="number">14</span>  <span class="comment"># 你想要设置的字体大小</span></span><br><span class="line"><span class="comment"># 修改 x 和 y 轴标签的字体大小</span></span><br><span class="line">ax.set_xlabel(ax.get_xlabel(), fontsize=fontsize)</span><br><span class="line">ax.set_ylabel(ax.get_ylabel(), fontsize=fontsize)</span><br><span class="line"><span class="comment"># 修改 x 轴和 y 轴刻度标签的字体大小</span></span><br><span class="line">ax.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=fontsize)</span><br><span class="line"><span class="comment"># 添加费米能级参考线</span></span><br><span class="line">ax.axhline(y=<span class="number">0</span>, color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 移除图例</span></span><br><span class="line">legend = ax.get_legend()</span><br><span class="line"><span class="keyword">if</span> legend <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    legend.remove()</span><br><span class="line"><span class="comment"># 移除 x 轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/27/Learn-VASP-from-pymatgen-9/image-20240628111627113.png" alt="image-20240628111627113"></p>
<p>现在看上去就顺眼了很多。单独绘制能带图的话，还是推荐使用<code>BSPlotter</code>方法，然后再修改</p>
<p><code>matplotlib</code>的属性来覆盖<code>get_plot()</code>方法中的默认参数。</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>Learn VASP from pymatgen</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>计算工具系列 —— Pyprocar库</title>
    <url>/2024/06/20/Pyprocar-tutorial-1/</url>
    <content><![CDATA[<p><em><strong>¡Hola a todos!</strong></em></p>
<p>最近学习了一下<code>Pyprocar</code>的用法，分享一下使用心得。</p>
<p>对于老司机这种天生反骨的打工人，每天想的都是怎么偷懒，但是又想保住份工，就只能在效率上面想办法了，总之就是：</p>
<blockquote>
<p><strong>Be lazy, stay efficient, and enjoy your coffee break!</strong></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>[官网](<a href="https://romerogroup.github.io/pyprocar/">PyProcar — PyProcar 6.1.10 documentation (romerogroup.github.io)</a>)：</p>
<blockquote>
<p><em><strong>PyProcar is a robust, open-source Python library used for pre- and post-processing of the electronic structure data coming from DFT calculations. PyProcar provides a set of functions that manage data from the PROCAR format obtained from various DFT codes. Basically, the PROCAR file is a projection of the Kohn-Sham states over atomic orbitals. That projection is performed to every 𝑘-point in the considered mesh, every energy band and every atom. PyProcar is capable of performing a multitude of tasks including plotting plain and spin/atom/orbital projected band structures and Fermi surfaces- both in 2D and 3D, Fermi velocity plots, unfolding bands of a super cell, comparing band structures from multiple DFT calculations, plotting partial density of states and generating a 𝑘-path for a given crystal structure.</strong></em></p>
</blockquote>
<p>简而言之，自动出图，解放双手。而且对比其他后处理软件，老司机个人感觉<code>Pyprocar</code>出的图相对来说已经比较好看了，作为工作狗来说妥妥够用不需要二次处理了；放在顶刊文章里可能还需要再编辑下，不过还好<code>Pyprocar</code>提供了<code>matplotlib</code>再处理的功能，所以对图片要求更加高大上的也不用担心，再次编辑就行了。</p>
<h2 id="处理能带"><a href="#处理能带" class="headerlink" title="处理能带"></a>处理能带</h2><p>能带VASP计算流程参照参照<code>Learn VASP from pyamtgen</code>系列——<a href="https://andyhox.github.io/2024/06/18/Learn-VASP-from-pymatgen-8/">Chap.8 计算小白硬学VASP —— 材料性质计算—&gt;能带计算 - A&amp;H (andyhox.github.io)</a>，直接处理案例的数据。</p>
<h3 id="Pyprocar后处理"><a href="#Pyprocar后处理" class="headerlink" title="Pyprocar后处理"></a>Pyprocar后处理</h3><h4 id="普通能带"><a href="#普通能带" class="headerlink" title="普通能带"></a>普通能带</h4><p><code>Pyprocar</code>的代码非常简单，只需要简单设置就可以得到基本的能带图，主要用到的方法为<code>pyprocar.bandsplot</code>。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line"><span class="comment"># 获取费米能级</span></span><br><span class="line">efermi=vasprun.efermi</span><br><span class="line"><span class="comment"># 打印gap信息</span></span><br><span class="line"><span class="built_in">print</span>(vasprun.get_band_structure().get_band_gap())</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"><span class="comment"># pyprocar设置</span></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,		<span class="comment"># 定义计算类型，默认为’vasp'</span></span><br><span class="line">    dirname=band_dir,	<span class="comment"># 指定文件路径，程序会自动读取对应文件</span></span><br><span class="line">    mode=<span class="string">'plain'</span>,		<span class="comment"># 处理模式，'plain'为绘制普通band</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p>首先调用<code>pymatgen</code>会输出gap信息：</p>
<blockquote>
<p><em><strong>{‘direct’: False, ‘energy’: 0.5058999999999987, ‘transition’: ‘GAMMA-X’}</strong></em></p>
</blockquote>
<p>结构为间接半导体，<strong>VBM→CBM</strong>方向为：<strong>GAMMA→X</strong>，禁带宽度为：<strong>0.5 eV</strong></p>
<p>默认参数输出的能带图：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620123342020.png" alt="image-20240620123342020"></p>
<p>ok，此时的能带图初见轮廓但是不利于分析。默认参数下没有平移费米能级至0，已经选择合适的energy interval，所以我们需要优化一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line"><span class="comment"># 获取费米能级</span></span><br><span class="line">efermi=vasprun.efermi</span><br><span class="line"><span class="comment"># 打印gap信息</span></span><br><span class="line"><span class="built_in">print</span>(vasprun.get_band_structure().get_band_gap())</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"><span class="comment"># pyprocar设置</span></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    <span class="comment"># 源参数</span></span><br><span class="line">    code=<span class="string">'vasp'</span>,		<span class="comment"># 定义计算类型，默认为’vasp'</span></span><br><span class="line">    dirname=band_dir,	<span class="comment"># 指定文件路径，程序会自动读取对应文件</span></span><br><span class="line">    mode=<span class="string">'plain'</span>,		<span class="comment"># 处理模式，'plain'为绘制普通band</span></span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],		<span class="comment"># 指定Energy interval</span></span><br><span class="line">    fermi=efermi,		<span class="comment"># 提供费米能级，参数中提供费米能级后，默认会平移至0</span></span><br><span class="line">    <span class="comment"># 绘图参数</span></span><br><span class="line">    linewidth=[<span class="number">2</span>],		<span class="comment"># 曲线宽度</span></span><br><span class="line">    fermi_linewidth=<span class="number">2</span>	<span class="comment"># 费米能级参考线线宽</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620124055490.png" alt="image-20240620124055490"></p>
<p>针对上述图片，我们增加了源参数：</p>
<ul>
<li><p><code>elimit</code>：控制纵坐标能量范围；</p>
</li>
<li><p><code>fermi</code>：提供费米能级</p>
</li>
</ul>
<p>源参数即<code>pyprocar.bandsplot</code>读取后输出对应的图，具体参数即含义可[参考文档](<a href="https://romerogroup.github.io/pyprocar/index.html">PyProcar — PyProcar 6.1.10 documentation (romerogroup.github.io)</a>)。参数有很多，但是实际操作中只需要设置几个参数就可以得到非常好的图了。</p>
<p>绘图参数是在此基础上调整图片的线宽，字体大小等，同样也只需要设置有限个参数就可以得到很好的图片了。</p>
<mark class="hl-label blue">绘图参数</mark>

<blockquote>
<p>spin_colors : {‘description’: ‘The colors for the plot lines.’, ‘value’: [‘blue’, ‘red’]}</p>
<p>color : {‘description’: ‘The colors for the plot lines.’, ‘value’: ‘black’}</p>
<p>colorbar_title : {‘description’: ‘Title of the colorbar.’, ‘value’: ‘Atomic Orbital Projections’}</p>
<p>colorbar_title_size : {‘description’: ‘Font size of the title of the colorbar.’, ‘value’: 15}</p>
<p>colorbar_title_padding : {‘description’: ‘Padding of the title of the colorbar.’, ‘value’: 20}</p>
<p>colorbar_tick_labelsize : {‘description’: ‘Size of the title of the colorbar ticks’, ‘value’: 10}</p>
<p>cmap : {‘description’: ‘The colormap used for the plot.’, ‘value’: ‘jet’}</p>
<p>clim : {‘description’: ‘The color scale for the color bar’, ‘value’: [None, None]}</p>
<p>fermi_color : {‘description’: ‘The color of the Fermi line.’, ‘value’: ‘blue’}</p>
<p>fermi_linestyle : {‘description’: ‘The linestyle of the Fermi line.’, ‘value’: ‘dotted’}</p>
<p>fermi_linewidth : {‘description’: ‘The linewidth of the Fermi line.’, ‘value’: 1}</p>
<p>grid : {‘description’: ‘If true, a grid will be shown on the plot.’, ‘value’: False}</p>
<p>grid_axis : {‘description’: ‘Which axis (or both) the grid lines should be drawn on.’, ‘value’: ‘both’}</p>
<p>grid_color : {‘description’: ‘The color of the grid lines.’, ‘value’: ‘grey’}</p>
<p>grid_linestyle : {‘description’: ‘The linestyle of the grid lines.’, ‘value’: ‘solid’}</p>
<p>grid_linewidth : {‘description’: ‘The linewidth of the grid lines.’, ‘value’: 1}</p>
<p>grid_which : {‘description’: ‘Which grid lines to draw (major, minor or both).’, ‘value’: ‘major’}</p>
<p>label : {‘description’: ‘The labels for the plot lines.’, ‘value’: [‘<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.437ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="2.007ex" role="img" focusable="false" viewbox="0 -694 500 887"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2191" d="M27 414Q17 414 17 433Q17 437 17 439T17 444T19 447T20 450T22 452T26 453T30 454T36 456Q80 467 120 494T180 549Q227 607 238 678Q240 694 251 694Q259 694 261 684Q261 677 265 659T284 608T320 549Q340 525 363 507T405 479T440 463T467 455T479 451Q483 447 483 433Q483 413 472 413Q467 413 458 416Q342 448 277 545L270 555V-179Q262 -193 252 -193H250H248Q236 -193 230 -179V555L223 545Q192 499 146 467T70 424T27 414Z"/></g></g></g></svg></mjx-container>’, ‘<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="2.009ex" role="img" focusable="false" viewbox="0 -694 500 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2193" d="M473 86Q483 86 483 67Q483 63 483 61T483 56T481 53T480 50T478 48T474 47T470 46T464 44Q428 35 391 14T316 -55T264 -168Q264 -170 263 -173T262 -180T261 -184Q259 -194 251 -194Q242 -194 238 -176T221 -121T180 -49Q169 -34 155 -21T125 2T95 20T67 33T44 42T27 47L21 49Q17 53 17 67Q17 87 28 87Q33 87 42 84Q158 52 223 -45L230 -55V312Q230 391 230 482T229 591Q229 662 231 676T243 693Q244 694 251 694Q264 692 270 679V-55L277 -45Q307 1 353 33T430 76T473 86Z"/></g></g></g></svg></mjx-container>’]}</p>
<p>legend : {‘description’: ‘If true, a legend will be shown on the plot.’, ‘value’: True}</p>
<p>linestyle : {‘description’: ‘The linestyles for the plot lines.’, ‘value’: [‘solid’, ‘dashed’]}</p>
<p>linewidth : {‘description’: ‘The linewidths for the plot lines.’, ‘value’: [1.0, 1.0]}</p>
<p>marker : {‘description’: ‘The marker styles for the plot points.’, ‘value’: [‘o’, ‘v’, ‘^’, ‘D’]}</p>
<p>markersize : {‘description’: ‘The size of the markers for the plot points.’, ‘value’: [0.2, 0.2]}</p>
<p>opacity : {‘description’: ‘The opacities for the plot lines.’, ‘value’: [1.0, 1.0]}</p>
<p>plot_color_bar : {‘description’: ‘If true, a color bar will be shown on the plot.’, ‘value’: True}</p>
<p>savefig : {‘description’: ‘The file name to save the figure. If null, the figure will not be saved.’, ‘value’: None}</p>
<p>title : {‘description’: ‘The title for the plot. If null, no title will be displayed.’, ‘value’: None}</p>
<p>weighted_color : {‘description’: ‘If true, the color of the lines will be weighted.’, ‘value’: True}</p>
<p>weighted_width : {‘description’: ‘If true, the width of the lines will be weighted.’, ‘value’: False}</p>
<p>figure_size : {‘description’: ‘The size of the figure (width, height) in inches.’, ‘value’: [9, 6]}</p>
<p>dpi : {‘description’: “The resolution in dots per inch. If ‘figure’, use the figure’s dpi value.”, ‘value’: ‘figure’}</p>
</blockquote>
<h4 id="轨道投影能带图"><a href="#轨道投影能带图" class="headerlink" title="轨道投影能带图"></a>轨道投影能带图</h4><h5 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h5><p><code>LORBIT</code>设置成12的话，轨道的分类如下：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/orbitals.png" alt="orbitals"></p>
<p>此时<code>pyprocar.bandsplot</code>中设置<code>mode=parametric</code>，同时也需要指定轨道：</p>
<ul>
<li><code>orbitals=[1]</code>：只分析<code>py</code>亚轨道；</li>
<li><code>orbitals=[1,2,3]</code>：分析全部p轨道;</li>
<li>以此类推……</li>
</ul>
<p>下面为primtive_cell的结果：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">s轨道</button><button type="button" class="tab">p轨道</button><button type="button" class="tab">d轨道</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line">efermi = vasprun.efermi</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    dirname=band_dir,</span><br><span class="line">    mode=<span class="string">'parametric'</span>,</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    orbitals=[<span class="number">0</span>],   <span class="comment"># s轨道</span></span><br><span class="line">    fermi=efermi,</span><br><span class="line">    clim=[<span class="number">0</span>,<span class="number">1</span>],		<span class="comment"># color bar的刻度</span></span><br><span class="line">    linewidth=[<span class="number">2</span>],</span><br><span class="line">    fermi_linewidth=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620142112989.png" alt="image-20240620142112989"></p></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line">efermi = vasprun.efermi</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    dirname=band_dir,</span><br><span class="line">    mode=<span class="string">'parametric'</span>,</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    orbitals=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   <span class="comment"># p轨道</span></span><br><span class="line">    fermi=efermi,</span><br><span class="line">    clim=[<span class="number">0</span>,<span class="number">1</span>],			<span class="comment"># color bar的刻度</span></span><br><span class="line">    linewidth=[<span class="number">2</span>],</span><br><span class="line">    fermi_linewidth=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620142145114.png" alt="image-20240620142145114"></p></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line">efermi = vasprun.efermi</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    dirname=band_dir,</span><br><span class="line">    mode=<span class="string">'parametric'</span>,</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    orbitals=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],   <span class="comment"># d轨道</span></span><br><span class="line">    fermi=efermi,</span><br><span class="line">    clim=[<span class="number">0</span>,<span class="number">1</span>],				<span class="comment"># color bar的刻度</span></span><br><span class="line">    linewidth=[<span class="number">2</span>],</span><br><span class="line">    fermi_linewidth=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620142220215.png" alt="image-20240620142220215"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>如果是对于自旋体系，在源参数中增加<code>spins</code>即可控制绘图考虑的自旋方向：</p>
<ul>
<li><code>spins=[0]</code>：绘制spin up</li>
<li><code>spins=[1]</code>：绘制spin down</li>
<li><code>spins=[0,1]</code>：同时绘制spin up &amp; spin down</li>
</ul>
<p>老司机这里计算的时候把自旋关了，所以输出也就只有一条，不用额外设置。</p>
<p>除此之外，还可以输出原子的贡献，操作就是把<code>oribitals</code>换成<code>atoms</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line">efermi = vasprun.efermi</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    dirname=band_dir,</span><br><span class="line">    mode=<span class="string">'parametric'</span>,</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    atoms=[<span class="number">0</span>],   			<span class="comment"># 1号原子贡献</span></span><br><span class="line">    fermi=efermi,</span><br><span class="line">    clim=[<span class="number">0</span>,<span class="number">1</span>],				<span class="comment"># color bar的刻度</span></span><br><span class="line">    linewidth=[<span class="number">2</span>],</span><br><span class="line">    fermi_linewidth=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620143531454.png" alt="image-20240620143531454"></p>
<p>如果想得到某一元素的贡献，只需要在<code>atoms=[]</code>中包含同一元素原子所有的序号即可，上面计算用到的primtive cell中每个元素只有一个原子，即上图为<code>Zr</code>元素的贡献。</p>
<h5 id="散点"><a href="#散点" class="headerlink" title="散点"></a>散点</h5><p>还可以用散点来表示，差别只是把<code>mode='parametric</code>‘换成<code>mode='scatter'</code>，其余设置一样，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">vasprun = Vasprun(<span class="string">'./ZrNiSn_primitive/band/vasprun.xml'</span>)</span><br><span class="line">efermi = vasprun.efermi</span><br><span class="line"></span><br><span class="line">band_dir = <span class="string">'./ZrNiSn_primitive/band'</span></span><br><span class="line"></span><br><span class="line">pyprocar.bandsplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    dirname=band_dir,</span><br><span class="line">    mode=<span class="string">'scatter'</span>,</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    atoms=[<span class="number">0</span>],   			<span class="comment"># 1号原子贡献</span></span><br><span class="line">    fermi=efermi,</span><br><span class="line">    clim=[<span class="number">0</span>,<span class="number">1</span>],				<span class="comment"># color bar的刻度</span></span><br><span class="line">    markersize=[<span class="number">60</span>],		<span class="comment"># 调整散点大小</span></span><br><span class="line">    fermi_linewidth=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240620144303956.png" alt="image-20240620144303956"></p>
<h2 id="处理态密度"><a href="#处理态密度" class="headerlink" title="处理态密度"></a>处理态密度</h2><p>态密度的处理方法与能带类似，使用<code>pyprocar.dosplot</code>，VASP计算流程参照<code>Learn VASP from pyamtgen</code>系列——<a href="https://andyhox.github.io/2024/06/11/Learn-VASP-from-pymatgen-5/">Chap.5 计算小白硬学VASP —— 材料性质计算—&gt;态密度 - A&amp;H (andyhox.github.io)</a>。</p>
<p>直接接着后处理上文<code>ZrNiSn</code>结构的态密度。</p>
<h3 id="Pyrocar-后处理"><a href="#Pyrocar-后处理" class="headerlink" title="Pyrocar 后处理"></a>Pyrocar 后处理</h3><h4 id="总态密度TDOS"><a href="#总态密度TDOS" class="headerlink" title="总态密度TDOS"></a>总态密度TDOS</h4><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line">prim_dos = pyprocar.dosplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    mode=<span class="string">'plain'</span>,</span><br><span class="line">    dirname=<span class="string">'ZrNiSn_primitive/dos'</span>,</span><br><span class="line">    fermi=prim_efermi,</span><br><span class="line">    elimit=[-<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">    dos_limit=[<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626154522277.png" alt="image-20240626154522277"></p>
<p>上述案例没有考虑<code>ISPIN</code>，故只显示一个方向。</p>
<h4 id="分态密度PDOS"><a href="#分态密度PDOS" class="headerlink" title="分态密度PDOS"></a>分态密度PDOS</h4><h5 id="指定元素和轨道"><a href="#指定元素和轨道" class="headerlink" title="指定元素和轨道"></a>指定元素和轨道</h5><p>这里可以绘制<code>ZrNiSn</code>中Zr-d、Ni-d、Sn-sp轨道，此时用到<code>mode=overlay</code>，同时也需要设置<code>items</code>指定元素及轨道。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># primtive_cell</span></span><br><span class="line"></span><br><span class="line">prim_dos = pyprocar.dosplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    mode=<span class="string">'overlay'</span>,</span><br><span class="line">    dirname=<span class="string">'ZrNiSn_primitive/dos'</span>,</span><br><span class="line">    fermi=prim_efermi,</span><br><span class="line">    items=<span class="built_in">dict</span>(Zr=(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>),Ni=(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>),Sn=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)),</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    dos_limit=[<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626155508247.png" alt="image-20240626155508247"></p>
<h5 id="分析指定原子的PDOS"><a href="#分析指定原子的PDOS" class="headerlink" title="分析指定原子的PDOS"></a>分析指定原子的PDOS</h5><p>如果需要分析指定编号单个原子或多个原子的PDOS，可以采用<code>mode=overlay_orbitals</code>方法，此时只需要指定<code>atoms</code>对应的原子序号列表，如这里分析Zr+Ni的PDOS。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># primtive_cell</span></span><br><span class="line"></span><br><span class="line">prim_dos = pyprocar.dosplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    mode=<span class="string">'overlay_orbitals'</span>,</span><br><span class="line">    dirname=<span class="string">'ZrNiSn_primitive/dos'</span>,</span><br><span class="line">    fermi=prim_efermi,</span><br><span class="line">    atoms=[<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    dos_limit=[<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626161041969.png" alt="image-20240626161041969"></p>
<h5 id="指定所有元素同一个轨道"><a href="#指定所有元素同一个轨道" class="headerlink" title="指定所有元素同一个轨道"></a>指定所有元素同一个轨道</h5><p>如果对于给定的体系需要分析所有元素的同一个轨道，比如过渡金属高熵合金只看d轨道的话，可以采用<code>mode=overlay_species</code>，且只需要指定<code>orbitals</code>即可。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># primtive_cell</span></span><br><span class="line"></span><br><span class="line">prim_dos = pyprocar.dosplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    mode=<span class="string">'overlay_species'</span>,</span><br><span class="line">    dirname=<span class="string">'ZrNiSn_primitive/dos'</span>,</span><br><span class="line">    fermi=prim_efermi,</span><br><span class="line">    orbitals=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    dos_limit=[<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626160253746.png" alt="image-20240626160253746"></p>
<p>初次之外，图片还可以垂直的方式输出，只需要添加<code>orientation='vertical'</code>，如上述代码改为垂直输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line"><span class="comment"># primtive_cell</span></span><br><span class="line"></span><br><span class="line">prim_dos = pyprocar.dosplot(</span><br><span class="line">    code=<span class="string">'vasp'</span>,</span><br><span class="line">    mode=<span class="string">'overlay_species'</span>,</span><br><span class="line">    orientation=<span class="string">'vertical'</span>,</span><br><span class="line">    dirname=<span class="string">'ZrNiSn_primitive/dos'</span>,</span><br><span class="line">    fermi=prim_efermi,</span><br><span class="line">    orbitals=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    elimit=[-<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    dos_limit=[<span class="number">0</span>,<span class="number">50</span>],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626161701325.png" alt="image-20240626161701325"></p>
<h2 id="同时绘制能带态密度"><a href="#同时绘制能带态密度" class="headerlink" title="同时绘制能带态密度"></a>同时绘制能带态密度</h2><p>用到<code>pyprocar.bandsdosplot</code>方法，只需要分别设置<code>band</code>和<code>dos</code>的参数，然后用<code>bandsdosplot</code>组合在一起即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyprocar</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Vasprun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取vasprun.xml文件</span></span><br><span class="line">prim_dos_vrun = Vasprun(<span class="string">"./ZrNiSn_primitive/dos/vasprun.xml"</span>)</span><br><span class="line">prim_efermi = prim_dos_vrun.efermi</span><br><span class="line"></span><br><span class="line">bands_settings = {</span><br><span class="line">                  <span class="string">'mode'</span>:<span class="string">'plain'</span>,</span><br><span class="line">                  <span class="string">'fermi'</span>:prim_efermi, </span><br><span class="line">                  <span class="string">'dirname'</span>: bands_dir</span><br><span class="line">                  }</span><br><span class="line"></span><br><span class="line">dos_settings = {</span><br><span class="line">               <span class="string">'mode'</span>:<span class="string">'plain'</span>,</span><br><span class="line">               <span class="string">'fermi'</span>:prim_efermi,   </span><br><span class="line">               <span class="string">'dirname'</span>: dos_dir</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">pyprocar.bandsdosplot(code=<span class="string">'vasp'</span>,</span><br><span class="line">                bands_settings=bands_settings,</span><br><span class="line">                dos_settings=dos_settings,</span><br><span class="line">                )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<p><img src="/2024/06/20/Pyprocar-tutorial-1/image-20240626170909285.png" alt="image-20240626170909285"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Pyprocar</code>的用法就介绍到这，欢迎补充！</p>
<p><em><strong>¡Muchas gracias!</strong></em></p>
]]></content>
      <categories>
        <category>toolkit</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>Pyprocar</tag>
        <tag>Band</tag>
        <tag>DOS</tag>
      </tags>
  </entry>
</search>
